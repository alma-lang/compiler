---
source: src/compiler/mod.rs
assertion_line: 284
expression: "compile(&[r#\"\nmodule Test exposing (main, Option(Some, None))\n\ntype Option a = Some a | None\n\ntype Id = Id Float\n\nmain =\n    let Id id = Id 1\n    let test = when Id 5 is\n        Id id -> id\n    let test = when \"test\" is\n        \"banana\" -> id\n        \"phone\" -> id\n    let test = when 5 is\n        5 -> id\n        _ -> id\n    let test = when Some(Id(1)) is\n        Some (Id id) -> id\n    Some id\n\n        \"#])"
---
// alma_out/Alma.ffi.js

export const or_ = (x, y) => x || y;
export const and_ = (x, y) => x && y;

export const eq = (x, y) => x === y;
export const ne = (x, y) => x !== y;

export const gt = (x, y) => x > y;
export const ge = (x, y) => x >= y;
export const lt = (x, y) => x < y;
export const le = (x, y) => x <= y;

export const add = (x, y) => x + y;
export const sub = (x, y) => x - y;
export const mult = (x, y) => x * y;
export const div = (x, y) => x / y;

export const Bool__True = true;
export const Bool__False = false;



// alma_out/Alma.js

/*

module Alma



False : ∀ ∅ . Bool

True : ∀ ∅ . Bool



add : ∀ ∅ . Float -> Float -> Float

and_ : ∀ ∅ . Bool -> Bool -> Bool

div : ∀ ∅ . Float -> Float -> Float

eq : ∀ a . a -> a -> Bool

ge : ∀ ∅ . Float -> Float -> Bool

gt : ∀ ∅ . Float -> Float -> Bool

le : ∀ ∅ . Float -> Float -> Bool

lt : ∀ ∅ . Float -> Float -> Bool

mult : ∀ ∅ . Float -> Float -> Float

ne : ∀ a . a -> a -> Bool

or_ : ∀ ∅ . Bool -> Bool -> Bool

sub : ∀ ∅ . Float -> Float -> Float

*/


import * as Alma__ffi from "./Alma.ffi.js"


// type Bool

let True = {
    __tag: "True",
}

let False = {
    __tag: "False",
}


let or_ = Alma__ffi.or_

let and_ = Alma__ffi.and_

let eq = Alma__ffi.eq

let ne = Alma__ffi.ne

let gt = Alma__ffi.gt

let ge = Alma__ffi.ge

let lt = Alma__ffi.lt

let le = Alma__ffi.le

let add = Alma__ffi.add

let sub = Alma__ffi.sub

let mult = Alma__ffi.mult

let div = Alma__ffi.div

export {
    // type Bool
    True,
    False,
    // end type Bool
    or_,
    and_,
    eq,
    ne,
    gt,
    ge,
    lt,
    le,
    add,
    sub,
    mult,
    div,
}



// alma_out/Test.js

/*

module Test

None : ∀ a . Option a

Some : ∀ a . a -> Option a

main : ∀ ∅ . Option Float

*/



import * as Alma from "./Alma.js"
import { True, False } from "./Alma.js"

// type Option

function Some(_0) {
    return {
        __tag: "Some",
        _0,
    }
}

let None = {
    __tag: "None",
    _0: null,
}

// type Id

function Id(_0) {
    return {
        __tag: "Id",
        _0,
    }
}

let main = function() {
    let { _0: id } = Id(1)
    return function() {
        let test = function () {
            let __result = Id(5)
            if (__result.__tag === "Id") {
                let id = __result._0
                return id
            }

            throw new Error("Incomplete pattern match")
        }()
        return function() {
            let test = function () {
                let __result = "test"
                if (__result === "banana") {
                    return id
                }
                if (__result === "phone") {
                    return id
                }

                throw new Error("Incomplete pattern match")
            }()
            return function() {
                let test = function () {
                    let __result = 5
                    if (__result === 5) {
                        return id
                    }
                    return id

                    throw new Error("Incomplete pattern match")
                }()
                return function() {
                    let test = function () {
                        let __result = Some(Id(1))
                        if (__result.__tag === "Some" && __result._0.__tag === "Id") {
                            let id = __result._0._0
                            return id
                        }

                        throw new Error("Incomplete pattern match")
                    }()
                    return Some(id)
                }()
            }()
        }()
    }()
}()

export {
    main,
    // type Option
    Some,
    None,
    // end type Option
}




