// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var TypeEnv = require("./TypeEnv.js");
var Caml_obj = require("rescript/lib/js/caml_obj.js");
var Belt_List = require("rescript/lib/js/belt_List.js");
var Belt_MapString = require("rescript/lib/js/belt_MapString.js");
var Belt_HashMapInt = require("rescript/lib/js/belt_HashMapInt.js");
var Caml_exceptions = require("rescript/lib/js/caml_exceptions.js");

var $$TypeError = /* @__PURE__ */Caml_exceptions.create("Infer.TypeError");

function empty(param) {
  return {
          currentLevel: {
            contents: 1
          },
          currentTypeVar: {
            contents: 0
          }
        };
}

function enterLevel(state) {
  state.currentLevel.contents = state.currentLevel.contents + 1 | 0;
  
}

function exitLevel(state) {
  state.currentLevel.contents = state.currentLevel.contents - 1 | 0;
  
}

function newVar(state) {
  state.currentTypeVar.contents = state.currentTypeVar.contents + 1 | 0;
  return state.currentTypeVar.contents;
}

function newTypeVar(state) {
  return {
          TAG: /* TVar */0,
          _0: {
            contents: {
              TAG: /* Unbound */1,
              _0: newVar(state),
              _1: state.currentLevel.contents
            }
          }
        };
}

var State = {
  empty: empty,
  enterLevel: enterLevel,
  exitLevel: exitLevel,
  newVar: newVar,
  newTypeVar: newTypeVar
};

function inst(s, state) {
  var replaceTvs = function (tbl, _x) {
    while(true) {
      var x = _x;
      if (typeof x === "number") {
        return /* TUnit */0;
      }
      switch (x.TAG | 0) {
        case /* TVar */0 :
            var t = x._0.contents;
            if (t.TAG === /* Bound */0) {
              _x = t._0;
              continue ;
            }
            var t_ = Belt_HashMapInt.get(tbl, t._0);
            if (t_ !== undefined) {
              return t_;
            } else {
              return x;
            }
        case /* Fn */1 :
            return {
                    TAG: /* Fn */1,
                    _0: replaceTvs(tbl, x._0),
                    _1: replaceTvs(tbl, x._1)
                  };
        case /* PolyType */2 :
            var tvs = x._0;
            var tblCpy = Belt_HashMapInt.copy(tbl);
            Belt_List.forEach(tvs, (function(tblCpy){
                return function (param) {
                  return Belt_HashMapInt.remove(tblCpy, param);
                }
                }(tblCpy)));
            return {
                    TAG: /* PolyType */2,
                    _0: tvs,
                    _1: replaceTvs(tblCpy, x._1)
                  };
        
      }
    };
  };
  if (typeof s === "number") {
    return s;
  }
  if (s.TAG !== /* PolyType */2) {
    return s;
  }
  var tvsToReplace = Belt_HashMapInt.make(1);
  Belt_List.forEach(s._0, (function (tv) {
          return Belt_HashMapInt.set(tvsToReplace, tv, newTypeVar(state));
        }));
  return replaceTvs(tvsToReplace, s._1);
}

function occurs(aId, aLevel, _x) {
  while(true) {
    var x = _x;
    if (typeof x === "number") {
      return false;
    }
    switch (x.TAG | 0) {
      case /* TVar */0 :
          var bTypevar = x._0;
          var t = bTypevar.contents;
          if (t.TAG === /* Bound */0) {
            _x = t._0;
            continue ;
          }
          var bId = t._0;
          var minLevel = aLevel < t._1 ? aLevel : t._1;
          bTypevar.contents = {
            TAG: /* Unbound */1,
            _0: bId,
            _1: minLevel
          };
          return aId === bId;
      case /* Fn */1 :
          if (occurs(aId, aLevel, x._0)) {
            return true;
          }
          _x = x._1;
          continue ;
      case /* PolyType */2 :
          if (Belt_List.has(x._0, aId, (function (tv, aId) {
                    return aId === tv;
                  }))) {
            return false;
          }
          _x = x._1;
          continue ;
      
    }
  };
}

function unify(_t1, _t2) {
  while(true) {
    var t2 = _t2;
    var t1 = _t1;
    var exit = 0;
    var exit$1 = 0;
    if (typeof t1 === "number") {
      if (typeof t2 === "number") {
        return ;
      }
      switch (t2.TAG | 0) {
        case /* TVar */0 :
            exit$1 = 3;
            break;
        case /* Fn */1 :
        case /* PolyType */2 :
            throw {
                  RE_EXN_ID: $$TypeError,
                  Error: new Error()
                };
        
      }
    } else {
      switch (t1.TAG | 0) {
        case /* TVar */0 :
            var a$p = t1._0.contents;
            if (a$p.TAG === /* Bound */0) {
              _t1 = a$p._0;
              continue ;
            }
            exit$1 = 3;
            break;
        case /* Fn */1 :
            if (typeof t2 === "number") {
              throw {
                    RE_EXN_ID: $$TypeError,
                    Error: new Error()
                  };
            }
            switch (t2.TAG | 0) {
              case /* TVar */0 :
                  exit$1 = 3;
                  break;
              case /* Fn */1 :
                  unify(t1._0, t2._0);
                  _t2 = t2._1;
                  _t1 = t1._1;
                  continue ;
              case /* PolyType */2 :
                  throw {
                        RE_EXN_ID: $$TypeError,
                        Error: new Error()
                      };
              
            }
            break;
        case /* PolyType */2 :
            if (typeof t2 === "number") {
              throw {
                    RE_EXN_ID: $$TypeError,
                    Error: new Error()
                  };
            }
            switch (t2.TAG | 0) {
              case /* TVar */0 :
                  exit$1 = 3;
                  break;
              case /* Fn */1 :
                  throw {
                        RE_EXN_ID: $$TypeError,
                        Error: new Error()
                      };
              case /* PolyType */2 :
                  _t2 = t2._1;
                  _t1 = t1._1;
                  continue ;
              
            }
            break;
        
      }
    }
    if (exit$1 === 3) {
      if (typeof t2 === "number" || t2.TAG !== /* TVar */0) {
        exit = 2;
      } else {
        var b$p = t2._0.contents;
        if (b$p.TAG === /* Bound */0) {
          _t2 = b$p._0;
          continue ;
        }
        exit = 2;
      }
    }
    if (exit === 2 && typeof t1 !== "number" && t1.TAG === /* TVar */0) {
      var a = t1._0;
      var match = a.contents;
      if (match.TAG !== /* Bound */0) {
        if (Caml_obj.caml_equal(t1, t2)) {
          return ;
        }
        if (occurs(match._0, match._1, t2)) {
          throw {
                RE_EXN_ID: $$TypeError,
                Error: new Error()
              };
        }
        a.contents = {
          TAG: /* Bound */0,
          _0: t2
        };
        return ;
      }
      
    }
    if (typeof t2 === "number") {
      throw {
            RE_EXN_ID: $$TypeError,
            Error: new Error()
          };
    }
    if (t2.TAG === /* TVar */0) {
      var b = t2._0;
      var match$1 = b.contents;
      if (match$1.TAG === /* Bound */0) {
        throw {
              RE_EXN_ID: $$TypeError,
              Error: new Error()
            };
      }
      if (Caml_obj.caml_equal(t1, t2)) {
        return ;
      }
      if (occurs(match$1._0, match$1._1, t1)) {
        throw {
              RE_EXN_ID: $$TypeError,
              Error: new Error()
            };
      }
      b.contents = {
        TAG: /* Bound */0,
        _0: t1
      };
      return ;
    }
    throw {
          RE_EXN_ID: $$TypeError,
          Error: new Error()
        };
  };
}

function generalize(t, state) {
  var findAllTvs = function (_x) {
    while(true) {
      var x = _x;
      if (typeof x === "number") {
        return /* [] */0;
      }
      switch (x.TAG | 0) {
        case /* TVar */0 :
            var t = x._0.contents;
            if (t.TAG !== /* Bound */0) {
              if (t._1 > state.currentLevel.contents) {
                return {
                        hd: t._0,
                        tl: /* [] */0
                      };
              } else {
                return /* [] */0;
              }
            }
            _x = t._0;
            continue ;
        case /* Fn */1 :
            return Belt_List.concat(findAllTvs(x._0), findAllTvs(x._1));
        case /* PolyType */2 :
            var tvs = x._0;
            return Belt_List.keep(findAllTvs(x._1), (function(tvs){
                      return function (tv) {
                        return !Belt_List.has(tvs, tv, (function (a, b) {
                                      return a === b;
                                    }));
                      }
                      }(tvs)));
        
      }
    };
  };
  return {
          TAG: /* PolyType */2,
          _0: Belt_List.sort(findAllTvs(t), (function (a, b) {
                  return a - b | 0;
                })),
          _1: t
        };
}

function infer(x, env) {
  var state_currentLevel = {
    contents: 1
  };
  var state_currentTypeVar = {
    contents: 0
  };
  var state = {
    currentLevel: state_currentLevel,
    currentTypeVar: state_currentTypeVar
  };
  var inferRec = function (_env, _x) {
    while(true) {
      var x = _x;
      var env = _env;
      if (typeof x === "number") {
        return /* TUnit */0;
      }
      switch (x.TAG | 0) {
        case /* Identifier */0 :
            var s = TypeEnv.getExn(env, x._0);
            return inst(s, state);
        case /* Lambda */1 :
            var t = newTypeVar(state);
            var t$p = inferRec(Belt_MapString.set(env, x._0, t), x._1);
            return {
                    TAG: /* Fn */1,
                    _0: t,
                    _1: t$p
                  };
        case /* FnCall */2 :
            var t0 = inferRec(env, x._0);
            var t1 = inferRec(env, x._1);
            var t$p$1 = newTypeVar(state);
            unify(t0, {
                  TAG: /* Fn */1,
                  _0: t1,
                  _1: t$p$1
                });
            return t$p$1;
        case /* Let */3 :
            state_currentLevel.contents = state_currentLevel.contents + 1 | 0;
            var t$1 = inferRec(env, x._1);
            state_currentLevel.contents = state_currentLevel.contents - 1 | 0;
            _x = x._2;
            _env = Belt_MapString.set(env, x._0, generalize(t$1, state));
            continue ;
        
      }
    };
  };
  return inferRec(env, x);
}

exports.$$TypeError = $$TypeError;
exports.State = State;
exports.inst = inst;
exports.occurs = occurs;
exports.unify = unify;
exports.generalize = generalize;
exports.infer = infer;
/* No side effect */
