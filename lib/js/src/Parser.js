// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var $$Node = require("./Node.js");
var Js_exn = require("rescript/lib/js/js_exn.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_Float = require("rescript/lib/js/belt_Float.js");
var Belt_Result = require("rescript/lib/js/belt_Result.js");

function make(_input, token, message) {
  var message$1 = String(token.line) + ":" + String(token.column) + ": " + message;
  return {
          message: message$1,
          token: token
        };
}

function expectedButFound(input, token, message) {
  return make(input, token, message + ", but instead found: '" + token.lexeme + "'");
}

var ParseError = {
  make: make,
  expectedButFound: expectedButFound
};

function peek(state) {
  var token = Belt_Array.get(state.tokens, state.current);
  if (token !== undefined) {
    return token;
  } else {
    return Js_exn.raiseTypeError("Out of bounds access to tokens array");
  }
}

function advance(state) {
  var token = peek(state);
  if (token.kind !== /* Eof */37) {
    state.current = state.current + 1 | 0;
    return ;
  }
  
}

function primary(state) {
  var token = peek(state);
  var match = token.kind;
  if (match !== 0) {
    if (match >= 20) {
      switch (match) {
        case /* Identifier */20 :
            return {
                    TAG: 0,
                    _0: $$Node.make({
                          TAG: 3,
                          _0: token.lexeme,
                          [Symbol.for("name")]: "Identifier"
                        }, token, token),
                    [Symbol.for("name")]: "Ok"
                  };
        case /* String */21 :
            var value = token.lexeme.substring(1, token.lexeme.length - 1 | 0);
            return {
                    TAG: 0,
                    _0: $$Node.make({
                          TAG: 2,
                          _0: value,
                          [Symbol.for("name")]: "String"
                        }, token, token),
                    [Symbol.for("name")]: "Ok"
                  };
        case /* Number */22 :
            var n = Belt_Float.fromString(token.lexeme);
            if (n !== undefined) {
              return {
                      TAG: 0,
                      _0: $$Node.make({
                            TAG: 1,
                            _0: n,
                            [Symbol.for("name")]: "Number"
                          }, token, token),
                      [Symbol.for("name")]: "Ok"
                    };
            } else {
              return {
                      TAG: 1,
                      _0: make(state.input, token, "Failed to parse number token '" + token.lexeme + "'"),
                      [Symbol.for("name")]: "Error"
                    };
            }
        case /* True */27 :
            return {
                    TAG: 0,
                    _0: $$Node.make({
                          TAG: 0,
                          _0: true,
                          [Symbol.for("name")]: "Bool"
                        }, token, token),
                    [Symbol.for("name")]: "Ok"
                  };
        case /* False */28 :
            return {
                    TAG: 0,
                    _0: $$Node.make({
                          TAG: 0,
                          _0: false,
                          [Symbol.for("name")]: "Bool"
                        }, token, token),
                    [Symbol.for("name")]: "Ok"
                  };
        case /* And */23 :
        case /* Or */24 :
        case /* If */25 :
        case /* Else */26 :
        case /* Fun */29 :
        case /* Let */30 :
        case /* Import */31 :
        case /* As */32 :
        case /* Exports */33 :
        case /* Module */34 :
        case /* Comment */35 :
        case /* Newline */36 :
        case /* Eof */37 :
            break;
        
      }
    }
    
  } else {
    advance(state);
    return Belt_Result.flatMap(primary(state), (function (expr) {
                  var token = peek(state);
                  var match = token.kind;
                  if (match !== 1) {
                    return {
                            TAG: 1,
                            _0: expectedButFound(state.input, token, "Expected ')' after parenthesized expression"),
                            [Symbol.for("name")]: "Error"
                          };
                  } else {
                    return {
                            TAG: 0,
                            _0: expr,
                            [Symbol.for("name")]: "Ok"
                          };
                  }
                }));
  }
  return {
          TAG: 1,
          _0: expectedButFound(state.input, token, "Expected an expression (let, if, a lambda, some math, or primitive types)"),
          [Symbol.for("name")]: "Error"
        };
}

var expression = primary;

function parse(input, tokens) {
  var state = {
    input: input,
    tokens: tokens,
    current: 0
  };
  var result = primary(state);
  if (result.TAG === /* Ok */0) {
    return {
            TAG: 0,
            _0: result._0,
            [Symbol.for("name")]: "Ok"
          };
  } else {
    return {
            TAG: 1,
            _0: [result._0],
            [Symbol.for("name")]: "Error"
          };
  }
}

var $$String$1;

exports.$$String = $$String$1;
exports.ParseError = ParseError;
exports.peek = peek;
exports.advance = advance;
exports.expression = expression;
exports.primary = primary;
exports.parse = parse;
/* No side effect */
