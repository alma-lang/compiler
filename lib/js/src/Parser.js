// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var $$Node = require("./Node.js");
var Js_exn = require("rescript/lib/js/js_exn.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_Float = require("rescript/lib/js/belt_Float.js");
var Belt_Result = require("rescript/lib/js/belt_Result.js");

function make(_input, token, message) {
  var message$1 = String(token.line) + ":" + String(token.column) + ": " + message;
  return {
          message: message$1,
          token: token
        };
}

function expectedButFound(input, token, message) {
  return make(input, token, message + ", but instead found: '" + token.lexeme + "'");
}

var ParseError = {
  make: make,
  expectedButFound: expectedButFound
};

function peek(parser) {
  var token = Belt_Array.get(parser.tokens, parser.current);
  if (token !== undefined) {
    return token;
  } else {
    return Js_exn.raiseTypeError("Out of bounds access to tokens array");
  }
}

function advance(parser) {
  var token = peek(parser);
  if (token.kind !== /* Eof */37) {
    parser.current = parser.current + 1 | 0;
    return ;
  }
  
}

function call(parser) {
  var firstToken = peek(parser);
  return Belt_Result.flatMap(primary(parser), (function (expr) {
                return callR(parser, firstToken, expr);
              }));
}

function $$arguments(parser, args) {
  return Belt_Result.flatMap(call(parser), (function (expr) {
                args.push(expr);
                var match = peek(parser).kind;
                if (match !== 4) {
                  return {
                          TAG: 0,
                          _0: args,
                          [Symbol.for("name")]: "Ok"
                        };
                } else {
                  advance(parser);
                  return $$arguments(parser, args);
                }
              }));
}

function callR(parser, firstToken, returnExpr) {
  var callFirstToken = peek(parser);
  var match = callFirstToken.kind;
  if (match !== 0) {
    return {
            TAG: 0,
            _0: returnExpr,
            [Symbol.for("name")]: "Ok"
          };
  }
  advance(parser);
  var match$1 = peek(parser).kind;
  if (match$1 !== 1) {
    return Belt_Result.flatMap($$arguments(parser, []), (function (args) {
                  var lastToken = peek(parser);
                  var match = lastToken.kind;
                  if (match !== 1) {
                    return {
                            TAG: 1,
                            _0: expectedButFound(parser.input, peek(parser), "Expected a ',' and more arguments or a closing ')' for the list of arguments of the function call"),
                            [Symbol.for("name")]: "Error"
                          };
                  }
                  advance(parser);
                  var expr = Belt_Array.reduce(args, returnExpr, (function (expr, arg) {
                          return $$Node.make({
                                      TAG: 5,
                                      _0: expr,
                                      _1: arg,
                                      [Symbol.for("name")]: "FnCall"
                                    }, firstToken, lastToken);
                        }));
                  return callR(parser, firstToken, expr);
                }));
  }
  var lastToken = peek(parser);
  advance(parser);
  return {
          TAG: 0,
          _0: $$Node.make({
                TAG: 5,
                _0: returnExpr,
                _1: $$Node.make(/* Unit */0, callFirstToken, lastToken),
                [Symbol.for("name")]: "FnCall"
              }, firstToken, lastToken),
          [Symbol.for("name")]: "Ok"
        };
}

function primary(parser) {
  var token = peek(parser);
  var match = token.kind;
  var result;
  var exit = 0;
  if (match !== 0) {
    if (match >= 20) {
      switch (match) {
        case /* Identifier */20 :
            result = {
              TAG: 0,
              _0: $$Node.make({
                    TAG: 3,
                    _0: token.lexeme,
                    [Symbol.for("name")]: "Identifier"
                  }, token, token),
              [Symbol.for("name")]: "Ok"
            };
            break;
        case /* String */21 :
            var value = token.lexeme.substring(1, token.lexeme.length - 1 | 0);
            result = {
              TAG: 0,
              _0: $$Node.make({
                    TAG: 2,
                    _0: value,
                    [Symbol.for("name")]: "String"
                  }, token, token),
              [Symbol.for("name")]: "Ok"
            };
            break;
        case /* Number */22 :
            var n = Belt_Float.fromString(token.lexeme);
            result = n !== undefined ? ({
                  TAG: 0,
                  _0: $$Node.make({
                        TAG: 1,
                        _0: n,
                        [Symbol.for("name")]: "Number"
                      }, token, token),
                  [Symbol.for("name")]: "Ok"
                }) : ({
                  TAG: 1,
                  _0: make(parser.input, token, "Failed to parse number token '" + token.lexeme + "'"),
                  [Symbol.for("name")]: "Error"
                });
            break;
        case /* True */27 :
            result = {
              TAG: 0,
              _0: $$Node.make({
                    TAG: 0,
                    _0: true,
                    [Symbol.for("name")]: "Bool"
                  }, token, token),
              [Symbol.for("name")]: "Ok"
            };
            break;
        case /* False */28 :
            result = {
              TAG: 0,
              _0: $$Node.make({
                    TAG: 0,
                    _0: false,
                    [Symbol.for("name")]: "Bool"
                  }, token, token),
              [Symbol.for("name")]: "Ok"
            };
            break;
        case /* And */23 :
        case /* Or */24 :
        case /* If */25 :
        case /* Else */26 :
        case /* Fun */29 :
        case /* Let */30 :
        case /* Import */31 :
        case /* As */32 :
        case /* Exports */33 :
        case /* Module */34 :
        case /* Comment */35 :
        case /* Newline */36 :
        case /* Eof */37 :
            exit = 1;
            break;
        
      }
    } else {
      exit = 1;
    }
  } else {
    advance(parser);
    result = Belt_Result.flatMap(call(parser), (function (expr) {
            var token = peek(parser);
            var match = token.kind;
            if (match !== 1) {
              return {
                      TAG: 1,
                      _0: expectedButFound(parser.input, token, "Expected ')' after parenthesized expression"),
                      [Symbol.for("name")]: "Error"
                    };
            } else {
              return {
                      TAG: 0,
                      _0: expr,
                      [Symbol.for("name")]: "Ok"
                    };
            }
          }));
  }
  if (exit === 1) {
    result = {
      TAG: 1,
      _0: expectedButFound(parser.input, token, "Expected an expression (let, if, a lambda, some math, or primitive types)"),
      [Symbol.for("name")]: "Error"
    };
  }
  if (Belt_Result.isOk(result)) {
    advance(parser);
  }
  return result;
}

var expression = call;

function parse(input, tokens) {
  var parser = {
    input: input,
    tokens: tokens,
    current: 0
  };
  var result = call(parser);
  if (result.TAG === /* Ok */0) {
    return {
            TAG: 0,
            _0: result._0,
            [Symbol.for("name")]: "Ok"
          };
  } else {
    return {
            TAG: 1,
            _0: [result._0],
            [Symbol.for("name")]: "Error"
          };
  }
}

var $$String$1;

var JsArray;

exports.$$String = $$String$1;
exports.JsArray = JsArray;
exports.ParseError = ParseError;
exports.peek = peek;
exports.advance = advance;
exports.expression = expression;
exports.call = call;
exports.callR = callR;
exports.$$arguments = $$arguments;
exports.primary = primary;
exports.parse = parse;
/* No side effect */
