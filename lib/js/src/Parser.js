// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var $$Node = require("./Node.js");
var Input = require("./Input.js");
var Js_exn = require("rescript/lib/js/js_exn.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_Float = require("rescript/lib/js/belt_Float.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Belt_Result = require("rescript/lib/js/belt_Result.js");

function make(input, token, message) {
  var position = token.position;
  var lineNumber = token.line;
  var columnNumber = token.column;
  var message$1 = String(token.line) + ":" + String(token.column) + ": " + message + "\n\n" + Belt_Option.getWithDefault(Input.linesReportAtPositionWithPointer(input, position, lineNumber, columnNumber), "");
  return {
          message: message$1,
          token: token
        };
}

function expectedButFound(input, token, message) {
  return make(input, token, message + ", but instead found: '" + token.lexeme + "'");
}

var ParseError = {
  make: make,
  expectedButFound: expectedButFound
};

function getToken(parser) {
  var token = Belt_Array.get(parser.tokens, parser.current);
  if (token !== undefined) {
    return token;
  } else {
    return Js_exn.raiseTypeError("Out of bounds access to tokens array");
  }
}

function advance(parser) {
  var token = getToken(parser);
  if (token.kind !== /* Eof */37) {
    parser.current = parser.current + 1 | 0;
    return ;
  }
  
}

function call$p(parser) {
  return Belt_Result.flatMap(primary(parser), (function (expr) {
                if (expr !== undefined) {
                  return callR$p(parser, expr);
                } else {
                  return {
                          TAG: 1,
                          _0: expectedButFound(parser.input, getToken(parser), "Expected an expression (let binding, function call, an identifier, etc.)"),
                          [Symbol.for("name")]: "Error"
                        };
                }
              }));
}

function primary(parser) {
  var token = getToken(parser);
  var match = token.kind;
  var result;
  if (match !== 0) {
    if (match >= 20) {
      switch (match) {
        case /* Identifier */20 :
            result = {
              TAG: 0,
              _0: $$Node.make({
                    TAG: 3,
                    _0: token.lexeme,
                    [Symbol.for("name")]: "Identifier"
                  }, token, token),
              [Symbol.for("name")]: "Ok"
            };
            break;
        case /* String */21 :
            var value = token.lexeme.substring(1, token.lexeme.length - 1 | 0);
            result = {
              TAG: 0,
              _0: $$Node.make({
                    TAG: 2,
                    _0: value,
                    [Symbol.for("name")]: "String"
                  }, token, token),
              [Symbol.for("name")]: "Ok"
            };
            break;
        case /* Number */22 :
            var n = Belt_Float.fromString(token.lexeme);
            result = n !== undefined ? ({
                  TAG: 0,
                  _0: $$Node.make({
                        TAG: 1,
                        _0: n,
                        [Symbol.for("name")]: "Number"
                      }, token, token),
                  [Symbol.for("name")]: "Ok"
                }) : ({
                  TAG: 1,
                  _0: make(parser.input, token, "Failed to parse number token '" + token.lexeme + "'"),
                  [Symbol.for("name")]: "Error"
                });
            break;
        case /* True */27 :
            result = {
              TAG: 0,
              _0: $$Node.make({
                    TAG: 0,
                    _0: true,
                    [Symbol.for("name")]: "Bool"
                  }, token, token),
              [Symbol.for("name")]: "Ok"
            };
            break;
        case /* False */28 :
            result = {
              TAG: 0,
              _0: $$Node.make({
                    TAG: 0,
                    _0: false,
                    [Symbol.for("name")]: "Bool"
                  }, token, token),
              [Symbol.for("name")]: "Ok"
            };
            break;
        case /* And */23 :
        case /* Or */24 :
        case /* If */25 :
        case /* Else */26 :
        case /* Fun */29 :
        case /* Let */30 :
        case /* Import */31 :
        case /* As */32 :
        case /* Exports */33 :
        case /* Module */34 :
        case /* Comment */35 :
        case /* Newline */36 :
        case /* Eof */37 :
            result = {
              TAG: 0,
              _0: undefined,
              [Symbol.for("name")]: "Ok"
            };
            break;
        
      }
    } else {
      result = {
        TAG: 0,
        _0: undefined,
        [Symbol.for("name")]: "Ok"
      };
    }
  } else {
    advance(parser);
    result = Belt_Result.flatMap(call$p(parser), (function (expr) {
            var token = getToken(parser);
            var match = token.kind;
            if (match !== 1) {
              return {
                      TAG: 1,
                      _0: expectedButFound(parser.input, token, "Expected ')' after parenthesized expression"),
                      [Symbol.for("name")]: "Error"
                    };
            } else {
              return {
                      TAG: 0,
                      _0: expr,
                      [Symbol.for("name")]: "Ok"
                    };
            }
          }));
  }
  if (result.TAG === /* Ok */0) {
    if (result._0 !== undefined) {
      advance(parser);
    }
    
  }
  return result;
}

function callR$p(parser, returnExpr) {
  return Belt_Result.flatMap(primary(parser), (function (arg) {
                if (arg !== undefined) {
                  return callR$p(parser, {
                              value: {
                                TAG: 5,
                                _0: returnExpr,
                                _1: arg,
                                [Symbol.for("name")]: "FnCall"
                              },
                              start: returnExpr.start,
                              end: arg.end
                            });
                } else {
                  return {
                          TAG: 0,
                          _0: returnExpr,
                          [Symbol.for("name")]: "Ok"
                        };
                }
              }));
}

var expression = call$p;

function file(parser) {
  var result = call$p(parser);
  if (result.TAG !== /* Ok */0) {
    return {
            TAG: 1,
            _0: [result._0],
            [Symbol.for("name")]: "Error"
          };
  }
  var token = getToken(parser);
  if (token.kind >= 37) {
    return {
            TAG: 0,
            _0: result._0,
            [Symbol.for("name")]: "Ok"
          };
  } else {
    return {
            TAG: 1,
            _0: [expectedButFound(parser.input, token, "Expected the end of input")],
            [Symbol.for("name")]: "Error"
          };
  }
}

function parse(input, tokens) {
  return file({
              input: input,
              tokens: tokens,
              current: 0
            });
}

var $$String$1;

var JsArray;

exports.$$String = $$String$1;
exports.JsArray = JsArray;
exports.ParseError = ParseError;
exports.getToken = getToken;
exports.advance = advance;
exports.expression = expression;
exports.call$p = call$p;
exports.callR$p = callR$p;
exports.primary = primary;
exports.file = file;
exports.parse = parse;
/* No side effect */
