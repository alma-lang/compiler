// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Caml_obj = require("rescript/lib/js/caml_obj.js");
var Belt_List = require("rescript/lib/js/belt_List.js");
var Belt_MapString = require("rescript/lib/js/belt_MapString.js");
var Belt_HashMapInt = require("rescript/lib/js/belt_HashMapInt.js");
var Caml_exceptions = require("rescript/lib/js/caml_exceptions.js");
var Caml_js_exceptions = require("rescript/lib/js/caml_js_exceptions.js");

var $$TypeError = /* @__PURE__ */Caml_exceptions.create("J.TypeError");

var currentLevel = {
  contents: 1
};

var currentTypeVar = {
  contents: 0
};

function enterLevel(param) {
  currentLevel.contents = currentLevel.contents + 1 | 0;
  
}

function exitLevel(param) {
  currentLevel.contents = currentLevel.contents - 1 | 0;
  
}

function newVar(param) {
  currentTypeVar.contents = currentTypeVar.contents + 1 | 0;
  return currentTypeVar.contents;
}

function newTypeVar(param) {
  return {
          TAG: /* TVar */0,
          _0: {
            contents: {
              TAG: /* Unbound */1,
              _0: newVar(undefined),
              _1: currentLevel.contents
            }
          }
        };
}

function nextLetter(s) {
  var c = s.contents.charCodeAt(0);
  s.contents = String.fromCharCode((c | 0) + 1 | 0);
  
}

function shouldParenthesize(_x) {
  while(true) {
    var x = _x;
    if (typeof x === "number") {
      return false;
    }
    switch (x.TAG | 0) {
      case /* TVar */0 :
          var t$p = x._0.contents;
          if (t$p.TAG !== /* Bound */0) {
            return false;
          }
          _x = t$p._0;
          continue ;
      case /* Fn */1 :
      case /* PolyType */2 :
          return true;
      
    }
  };
}

function toString(t) {
  var toStringRec = function (curTypeVarName, typeVarNames, _x) {
    while(true) {
      var x = _x;
      if (typeof x === "number") {
        return "unit";
      }
      switch (x.TAG | 0) {
        case /* TVar */0 :
            var t_ = x._0.contents;
            if (t_.TAG === /* Bound */0) {
              _x = t_._0;
              continue ;
            }
            var n = t_._0;
            var s = Belt_HashMapInt.get(typeVarNames, n);
            if (s !== undefined) {
              return s;
            }
            var s$1 = curTypeVarName.contents;
            Belt_HashMapInt.set(typeVarNames, n, s$1);
            nextLetter(curTypeVarName);
            return s$1;
        case /* Fn */1 :
            var a = x._0;
            var aStr = toStringRec(curTypeVarName, typeVarNames, a);
            var bStr = toStringRec(curTypeVarName, typeVarNames, x._1);
            if (shouldParenthesize(a)) {
              return "(" + (aStr + (") -> " + bStr));
            } else {
              return aStr + (" -> " + bStr);
            }
        case /* PolyType */2 :
            var curriedFn = function (t) {
              return toStringRec(curTypeVarName, typeVarNames, {
                          TAG: /* TVar */0,
                          _0: {
                            contents: {
                              TAG: /* Unbound */1,
                              _0: t,
                              _1: currentLevel.contents
                            }
                          }
                        });
            };
            var tvsStr = Belt_List.reduce(x._0, "", (function (s, tv) {
                    return s + (" '" + curriedFn(tv));
                  }));
            return "forall" + (tvsStr + (" . " + toStringRec(curTypeVarName, typeVarNames, x._1)));
        
      }
    };
  };
  return toStringRec({
              contents: "a"
            }, Belt_HashMapInt.make(1), t);
}

function printType(t) {
  console.log(toString(t));
  
}

function inst(s) {
  var replaceTvs = function (tbl, _x) {
    while(true) {
      var x = _x;
      if (typeof x === "number") {
        return /* TUnit */0;
      }
      switch (x.TAG | 0) {
        case /* TVar */0 :
            var t = x._0.contents;
            if (t.TAG === /* Bound */0) {
              _x = t._0;
              continue ;
            }
            var t_ = Belt_HashMapInt.get(tbl, t._0);
            if (t_ !== undefined) {
              return t_;
            } else {
              return x;
            }
        case /* Fn */1 :
            return {
                    TAG: /* Fn */1,
                    _0: replaceTvs(tbl, x._0),
                    _1: replaceTvs(tbl, x._1)
                  };
        case /* PolyType */2 :
            var tvs = x._0;
            var tblCpy = Belt_HashMapInt.copy(tbl);
            Belt_List.forEach(tvs, (function(tblCpy){
                return function (param) {
                  return Belt_HashMapInt.remove(tblCpy, param);
                }
                }(tblCpy)));
            return {
                    TAG: /* PolyType */2,
                    _0: tvs,
                    _1: replaceTvs(tblCpy, x._1)
                  };
        
      }
    };
  };
  if (typeof s === "number") {
    return s;
  }
  if (s.TAG !== /* PolyType */2) {
    return s;
  }
  var tvsToReplace = Belt_HashMapInt.make(1);
  Belt_List.forEach(s._0, (function (tv) {
          return Belt_HashMapInt.set(tvsToReplace, tv, newTypeVar(undefined));
        }));
  return replaceTvs(tvsToReplace, s._1);
}

function occurs(aId, aLevel, _x) {
  while(true) {
    var x = _x;
    if (typeof x === "number") {
      return false;
    }
    switch (x.TAG | 0) {
      case /* TVar */0 :
          var bTypevar = x._0;
          var t = bTypevar.contents;
          if (t.TAG === /* Bound */0) {
            _x = t._0;
            continue ;
          }
          var bId = t._0;
          var minLevel = aLevel < t._1 ? aLevel : t._1;
          bTypevar.contents = {
            TAG: /* Unbound */1,
            _0: bId,
            _1: minLevel
          };
          return aId === bId;
      case /* Fn */1 :
          if (occurs(aId, aLevel, x._0)) {
            return true;
          }
          _x = x._1;
          continue ;
      case /* PolyType */2 :
          if (Belt_List.has(x._0, aId, (function (tv, aId) {
                    return aId === tv;
                  }))) {
            return false;
          }
          _x = x._1;
          continue ;
      
    }
  };
}

function unify(_t1, _t2) {
  while(true) {
    var t2 = _t2;
    var t1 = _t1;
    var exit = 0;
    var exit$1 = 0;
    if (typeof t1 === "number") {
      if (typeof t2 === "number") {
        return ;
      }
      switch (t2.TAG | 0) {
        case /* TVar */0 :
            exit$1 = 3;
            break;
        case /* Fn */1 :
        case /* PolyType */2 :
            throw {
                  RE_EXN_ID: $$TypeError,
                  Error: new Error()
                };
        
      }
    } else {
      switch (t1.TAG | 0) {
        case /* TVar */0 :
            var a$p = t1._0.contents;
            if (a$p.TAG === /* Bound */0) {
              _t1 = a$p._0;
              continue ;
            }
            exit$1 = 3;
            break;
        case /* Fn */1 :
            if (typeof t2 === "number") {
              throw {
                    RE_EXN_ID: $$TypeError,
                    Error: new Error()
                  };
            }
            switch (t2.TAG | 0) {
              case /* TVar */0 :
                  exit$1 = 3;
                  break;
              case /* Fn */1 :
                  unify(t1._0, t2._0);
                  _t2 = t2._1;
                  _t1 = t1._1;
                  continue ;
              case /* PolyType */2 :
                  throw {
                        RE_EXN_ID: $$TypeError,
                        Error: new Error()
                      };
              
            }
            break;
        case /* PolyType */2 :
            if (typeof t2 === "number") {
              throw {
                    RE_EXN_ID: $$TypeError,
                    Error: new Error()
                  };
            }
            switch (t2.TAG | 0) {
              case /* TVar */0 :
                  exit$1 = 3;
                  break;
              case /* Fn */1 :
                  throw {
                        RE_EXN_ID: $$TypeError,
                        Error: new Error()
                      };
              case /* PolyType */2 :
                  _t2 = t2._1;
                  _t1 = t1._1;
                  continue ;
              
            }
            break;
        
      }
    }
    if (exit$1 === 3) {
      if (typeof t2 === "number" || t2.TAG !== /* TVar */0) {
        exit = 2;
      } else {
        var b$p = t2._0.contents;
        if (b$p.TAG === /* Bound */0) {
          _t2 = b$p._0;
          continue ;
        }
        exit = 2;
      }
    }
    if (exit === 2 && typeof t1 !== "number" && t1.TAG === /* TVar */0) {
      var a = t1._0;
      var match = a.contents;
      if (match.TAG !== /* Bound */0) {
        if (Caml_obj.caml_equal(t1, t2)) {
          return ;
        }
        if (occurs(match._0, match._1, t2)) {
          throw {
                RE_EXN_ID: $$TypeError,
                Error: new Error()
              };
        }
        a.contents = {
          TAG: /* Bound */0,
          _0: t2
        };
        return ;
      }
      
    }
    if (typeof t2 === "number") {
      throw {
            RE_EXN_ID: $$TypeError,
            Error: new Error()
          };
    }
    if (t2.TAG === /* TVar */0) {
      var b = t2._0;
      var match$1 = b.contents;
      if (match$1.TAG === /* Bound */0) {
        throw {
              RE_EXN_ID: $$TypeError,
              Error: new Error()
            };
      }
      if (Caml_obj.caml_equal(t1, t2)) {
        return ;
      }
      if (occurs(match$1._0, match$1._1, t1)) {
        throw {
              RE_EXN_ID: $$TypeError,
              Error: new Error()
            };
      }
      b.contents = {
        TAG: /* Bound */0,
        _0: t1
      };
      return ;
    }
    throw {
          RE_EXN_ID: $$TypeError,
          Error: new Error()
        };
  };
}

function generalize(t) {
  var findAllTvs = function (_x) {
    while(true) {
      var x = _x;
      if (typeof x === "number") {
        return /* [] */0;
      }
      switch (x.TAG | 0) {
        case /* TVar */0 :
            var t = x._0.contents;
            if (t.TAG !== /* Bound */0) {
              if (t._1 > currentLevel.contents) {
                return {
                        hd: t._0,
                        tl: /* [] */0
                      };
              } else {
                return /* [] */0;
              }
            }
            _x = t._0;
            continue ;
        case /* Fn */1 :
            return Belt_List.concat(findAllTvs(x._0), findAllTvs(x._1));
        case /* PolyType */2 :
            var tvs = x._0;
            return Belt_List.keep(findAllTvs(x._1), (function(tvs){
                      return function (tv) {
                        return !Belt_List.has(tvs, tv, (function (a, b) {
                                      return a === b;
                                    }));
                      }
                      }(tvs)));
        
      }
    };
  };
  return {
          TAG: /* PolyType */2,
          _0: Belt_List.sort(findAllTvs(t), (function (a, b) {
                  return a - b | 0;
                })),
          _1: t
        };
}

function infer(_env, _x) {
  while(true) {
    var x = _x;
    var env = _env;
    if (typeof x === "number") {
      return /* TUnit */0;
    }
    switch (x.TAG | 0) {
      case /* Identifier */0 :
          return inst(Belt_MapString.getExn(env, x._0));
      case /* Lambda */1 :
          var t = newTypeVar(undefined);
          var t$p = infer(Belt_MapString.set(env, x._0, t), x._1);
          return {
                  TAG: /* Fn */1,
                  _0: t,
                  _1: t$p
                };
      case /* FnCall */2 :
          var t0 = infer(env, x._0);
          var t1 = infer(env, x._1);
          var t$p$1 = newTypeVar(undefined);
          unify(t0, {
                TAG: /* Fn */1,
                _0: t1,
                _1: t$p$1
              });
          return t$p$1;
      case /* Let */3 :
          currentLevel.contents = currentLevel.contents + 1 | 0;
          var t$1 = infer(env, x._1);
          currentLevel.contents = currentLevel.contents - 1 | 0;
          _x = x._2;
          _env = Belt_MapString.set(env, x._0, generalize(t$1));
          continue ;
      
    }
  };
}

var Type = {
  currentLevel: currentLevel,
  currentTypeVar: currentTypeVar,
  enterLevel: enterLevel,
  exitLevel: exitLevel,
  newVar: newVar,
  newTypeVar: newTypeVar,
  nextLetter: nextLetter,
  shouldParenthesize: shouldParenthesize,
  toString: toString,
  printType: printType,
  inst: inst,
  occurs: occurs,
  unify: unify,
  generalize: generalize,
  infer: infer
};

function exprToString(ast) {
  if (typeof ast === "number") {
    return "()";
  }
  switch (ast.TAG | 0) {
    case /* Identifier */0 :
        return ast._0;
    case /* Lambda */1 :
        return "Î»" + ast._0 + ". " + exprToString(ast._1);
    case /* FnCall */2 :
        return "(" + exprToString(ast._0) + " " + exprToString(ast._1) + ")";
    case /* Let */3 :
        return "let " + ast._0 + " = " + exprToString(ast._1) + " in " + exprToString(ast._2);
    
  }
}

function test(name, ast, expected) {
  try {
    var typ = infer(undefined, ast);
    var correct = expected === toString(typ);
    console.log("  " + (
          correct ? "" : name
        ) + " " + (
          correct ? "" : ":"
        ) + " " + (
          correct ? "" : toString(typ)
        ));
    console.log((
          correct ? " " : "x"
        ) + " " + name + " : " + toString(typ));
    console.log("  " + name + " : " + exprToString(ast));
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === $$TypeError) {
      console.log("type error");
    } else {
      throw exn;
    }
  }
  currentTypeVar.contents = 0;
  
}

test("1", {
      TAG: /* Lambda */1,
      _0: "f",
      _1: {
        TAG: /* Lambda */1,
        _0: "x",
        _1: {
          TAG: /* FnCall */2,
          _0: {
            TAG: /* Identifier */0,
            _0: "f"
          },
          _1: {
            TAG: /* Identifier */0,
            _0: "x"
          }
        }
      }
    }, "(a -> b) -> a -> b");

test("2", {
      TAG: /* Lambda */1,
      _0: "f",
      _1: {
        TAG: /* Lambda */1,
        _0: "x",
        _1: {
          TAG: /* FnCall */2,
          _0: {
            TAG: /* Identifier */0,
            _0: "f"
          },
          _1: {
            TAG: /* FnCall */2,
            _0: {
              TAG: /* Identifier */0,
              _0: "f"
            },
            _1: {
              TAG: /* Identifier */0,
              _0: "x"
            }
          }
        }
      }
    }, "(a -> a) -> a -> a");

test("(+)", {
      TAG: /* Lambda */1,
      _0: "m",
      _1: {
        TAG: /* Lambda */1,
        _0: "n",
        _1: {
          TAG: /* Lambda */1,
          _0: "f",
          _1: {
            TAG: /* Lambda */1,
            _0: "x",
            _1: {
              TAG: /* FnCall */2,
              _0: {
                TAG: /* FnCall */2,
                _0: {
                  TAG: /* Identifier */0,
                  _0: "m"
                },
                _1: {
                  TAG: /* Identifier */0,
                  _0: "f"
                }
              },
              _1: {
                TAG: /* FnCall */2,
                _0: {
                  TAG: /* FnCall */2,
                  _0: {
                    TAG: /* Identifier */0,
                    _0: "n"
                  },
                  _1: {
                    TAG: /* Identifier */0,
                    _0: "f"
                  }
                },
                _1: {
                  TAG: /* Identifier */0,
                  _0: "x"
                }
              }
            }
          }
        }
      }
    }, "(a -> b -> c) -> (a -> d -> b) -> a -> d -> c");

test("succ", {
      TAG: /* Lambda */1,
      _0: "n",
      _1: {
        TAG: /* Lambda */1,
        _0: "f",
        _1: {
          TAG: /* Lambda */1,
          _0: "x",
          _1: {
            TAG: /* FnCall */2,
            _0: {
              TAG: /* Identifier */0,
              _0: "f"
            },
            _1: {
              TAG: /* FnCall */2,
              _0: {
                TAG: /* FnCall */2,
                _0: {
                  TAG: /* Identifier */0,
                  _0: "n"
                },
                _1: {
                  TAG: /* Identifier */0,
                  _0: "f"
                }
              },
              _1: {
                TAG: /* Identifier */0,
                _0: "x"
              }
            }
          }
        }
      }
    }, "((a -> b) -> c -> a) -> (a -> b) -> c -> b");

test("mult", {
      TAG: /* Lambda */1,
      _0: "m",
      _1: {
        TAG: /* Lambda */1,
        _0: "n",
        _1: {
          TAG: /* Lambda */1,
          _0: "f",
          _1: {
            TAG: /* Lambda */1,
            _0: "x",
            _1: {
              TAG: /* FnCall */2,
              _0: {
                TAG: /* FnCall */2,
                _0: {
                  TAG: /* Identifier */0,
                  _0: "m"
                },
                _1: {
                  TAG: /* FnCall */2,
                  _0: {
                    TAG: /* Identifier */0,
                    _0: "n"
                  },
                  _1: {
                    TAG: /* Identifier */0,
                    _0: "f"
                  }
                }
              },
              _1: {
                TAG: /* Identifier */0,
                _0: "x"
              }
            }
          }
        }
      }
    }, "(a -> b -> c) -> (d -> a) -> d -> b -> c");

test("pred", {
      TAG: /* Lambda */1,
      _0: "n",
      _1: {
        TAG: /* Lambda */1,
        _0: "f",
        _1: {
          TAG: /* Lambda */1,
          _0: "x",
          _1: {
            TAG: /* FnCall */2,
            _0: {
              TAG: /* FnCall */2,
              _0: {
                TAG: /* FnCall */2,
                _0: {
                  TAG: /* Identifier */0,
                  _0: "n"
                },
                _1: {
                  TAG: /* Lambda */1,
                  _0: "g",
                  _1: {
                    TAG: /* Lambda */1,
                    _0: "h",
                    _1: {
                      TAG: /* FnCall */2,
                      _0: {
                        TAG: /* Identifier */0,
                        _0: "h"
                      },
                      _1: {
                        TAG: /* FnCall */2,
                        _0: {
                          TAG: /* Identifier */0,
                          _0: "g"
                        },
                        _1: {
                          TAG: /* Identifier */0,
                          _0: "f"
                        }
                      }
                    }
                  }
                }
              },
              _1: {
                TAG: /* Lambda */1,
                _0: "u",
                _1: {
                  TAG: /* Identifier */0,
                  _0: "x"
                }
              }
            },
            _1: {
              TAG: /* Lambda */1,
              _0: "u",
              _1: {
                TAG: /* Identifier */0,
                _0: "u"
              }
            }
          }
        }
      }
    }, "(((a -> b) -> (b -> c) -> c) -> (d -> e) -> (f -> f) -> g) -> a -> e -> g");

test("let1", {
      TAG: /* Lambda */1,
      _0: "x",
      _1: {
        TAG: /* Let */3,
        _0: "y",
        _1: {
          TAG: /* Identifier */0,
          _0: "x"
        },
        _2: {
          TAG: /* Identifier */0,
          _0: "y"
        }
      }
    }, "a -> a");

test("let2", {
      TAG: /* Lambda */1,
      _0: "x",
      _1: {
        TAG: /* Let */3,
        _0: "y",
        _1: {
          TAG: /* Lambda */1,
          _0: "z",
          _1: {
            TAG: /* Identifier */0,
            _0: "x"
          }
        },
        _2: {
          TAG: /* Identifier */0,
          _0: "y"
        }
      }
    }, "a -> b -> a");

exports.$$TypeError = $$TypeError;
exports.Type = Type;
exports.exprToString = exprToString;
exports.test = test;
/*  Not a pure module */
