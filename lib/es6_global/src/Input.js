// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml from "../../../node_modules/rescript/lib/es6/caml.js";
import * as Js_exn from "../../../node_modules/rescript/lib/es6/js_exn.js";
import * as Belt_Array from "../../../node_modules/rescript/lib/es6/belt_Array.js";
import * as Belt_Option from "../../../node_modules/rescript/lib/es6/belt_Option.js";

var newLine = "\n";

function lineSubstring(input, from, to_) {
  return input.substring(from, to_ === (input.length - 1 | 0) && input.charAt(to_) !== newLine ? to_ + 1 | 0 : to_);
}

function lineAt(input, position) {
  if (input.length === 0 || position < 0 || position >= input.length) {
    return ;
  }
  var position$1 = position;
  var $$break = false;
  while(!$$break) {
    var prevPosition = position$1 - 1 | 0;
    if (prevPosition < 0 || input.charAt(prevPosition) === newLine) {
      $$break = true;
    } else {
      position$1 = prevPosition;
    }
  };
  var start = position$1;
  var position$2 = position;
  var $$break$1 = false;
  while(!$$break$1) {
    var nextPosition = position$2 + 1 | 0;
    if (nextPosition >= input.length || input.charAt(position$2) === newLine) {
      $$break$1 = true;
    } else {
      position$2 = nextPosition;
    }
  };
  var end = position$2;
  return [
          start,
          end
        ];
}

function linesBeforePosition(input, lines, _position, _howManyLines) {
  while(true) {
    var howManyLines = _howManyLines;
    var position = _position;
    var match = lineAt(input, position);
    if (match === undefined) {
      return lines.reverse();
    }
    if (howManyLines <= 0) {
      return lines.reverse();
    }
    var lineStart = match[0];
    var line = lineSubstring(input, lineStart, match[1]);
    lines.push(line);
    _howManyLines = howManyLines - 1 | 0;
    _position = lineStart - 1 | 0;
    continue ;
  };
}

function linesAfterPosition(input, lines, _position, _howManyLines) {
  while(true) {
    var howManyLines = _howManyLines;
    var position = _position;
    var match = lineAt(input, position);
    if (match === undefined) {
      return lines;
    }
    if (howManyLines <= 0) {
      return lines;
    }
    var lineEnd = match[1];
    var line = lineSubstring(input, match[0], lineEnd);
    lines.push(line);
    _howManyLines = howManyLines - 1 | 0;
    _position = lineEnd + 1 | 0;
    continue ;
  };
}

function linesAroundPosition(input, position, end, numberOfLines) {
  var maybeStartLine = lineAt(input, position);
  var maybeEndLine = Belt_Option.flatMap(end, (function (end) {
          return lineAt(input, end - 1 | 0);
        }));
  if (maybeStartLine === undefined) {
    return ;
  }
  var lineEnd = maybeStartLine[1];
  var lineStart = maybeStartLine[0];
  if (end !== undefined) {
    if (maybeEndLine === undefined) {
      return ;
    }
    var endLineEnd = maybeEndLine[1];
    var lines = lineSubstring(input, lineStart, endLineEnd).split("\n");
    var linesBefore = linesBeforePosition(input, [], lineStart - 1 | 0, numberOfLines);
    var linesAfter = linesAfterPosition(input, [], endLineEnd + 1 | 0, numberOfLines);
    return [
            linesBefore,
            [
              lineStart,
              endLineEnd,
              lines
            ],
            linesAfter
          ];
  }
  var line = lineSubstring(input, lineStart, lineEnd);
  var linesBefore$1 = linesBeforePosition(input, [], lineStart - 1 | 0, numberOfLines);
  var linesAfter$1 = linesAfterPosition(input, [], lineEnd + 1 | 0, numberOfLines);
  return [
          linesBefore$1,
          [
            lineStart,
            lineEnd,
            [line]
          ],
          linesAfter$1
        ];
}

function linesReportAtPositionWithPointer(position, lineNumber, end, input) {
  var pointToEndOfInput = position === input.length;
  var position$1 = pointToEndOfInput ? position - 1 | 0 : position;
  var end$1 = pointToEndOfInput ? undefined : end;
  return Belt_Option.map(linesAroundPosition(input, position$1, end$1, 2), (function (param) {
                var linesAfter = param[2];
                var match = param[1];
                var lines = match[2];
                var linesBefore = param[0];
                var out = [];
                var lineNumberWidth = String((lineNumber + (lines.length - 1 | 0) | 0) + linesAfter.length | 0).length;
                var columnNumber = position$1 - match[0] | 0;
                Belt_Array.forEachWithIndex(linesBefore, (function (i, l) {
                        var ln = String((lineNumber - linesBefore.length | 0) + i | 0).padStart(lineNumberWidth, " ");
                        out.push("  " + ln + "│  " + l);
                        
                      }));
                var len = lines.length;
                if (len !== 1) {
                  if (len !== 0) {
                    Belt_Array.forEachWithIndex(lines, (function (index, line) {
                            var ln = String(lineNumber + index | 0).padStart(lineNumberWidth, " ");
                            out.push("  " + ln + "│→ " + line);
                            
                          }));
                  } else {
                    Js_exn.raiseError("Couldn't locate code:\n\n" + input + "\n\n" + position$1 + ", " + lineNumber + ", " + end$1);
                  }
                } else {
                  var line = lines[0];
                  var ln = String(lineNumber).padStart(lineNumberWidth, " ");
                  out.push("  " + ln + "│  " + line);
                  var lineNumberAsSpaces = " ".padStart(lineNumberWidth, " ");
                  var numPointers = pointToEndOfInput ? 1 : Caml.caml_int_max(1, Belt_Option.getWithDefault(end$1, position$1) - position$1 | 0);
                  var pointers = "↑".repeat(numPointers);
                  var numSpaces = pointToEndOfInput ? columnNumber + 1 | 0 : columnNumber;
                  var spaces = " ".repeat(numSpaces);
                  out.push("  " + lineNumberAsSpaces + "│  " + spaces + pointers);
                }
                Belt_Array.forEachWithIndex(linesAfter, (function (i, l) {
                        var ln = String((lineNumber + lines.length | 0) + i | 0).padStart(lineNumberWidth, " ");
                        out.push("  " + ln + "│  " + l);
                        
                      }));
                return out.join("\n");
              }));
}

var $$String$1;

var JsArray;

export {
  $$String$1 as $$String,
  JsArray ,
  newLine ,
  lineSubstring ,
  lineAt ,
  linesBeforePosition ,
  linesAfterPosition ,
  linesAroundPosition ,
  linesReportAtPositionWithPointer ,
  
}
/* No side effect */
