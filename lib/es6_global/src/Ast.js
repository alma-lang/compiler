// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "../../../node_modules/rescript/lib/es6/belt_Array.js";

var Binop_or = {
  typ: /* Or */0,
  precedence: 6,
  associativity: /* LTR */0,
  fn: "(or)"
};

var Binop_and_ = {
  typ: /* And */1,
  precedence: 7,
  associativity: /* LTR */0,
  fn: "(and)"
};

var Binop_equal = {
  typ: /* Equal */2,
  precedence: 11,
  associativity: /* LTR */0,
  fn: "(==)"
};

var Binop_notEqual = {
  typ: /* NotEqual */3,
  precedence: 11,
  associativity: /* LTR */0,
  fn: "(!=)"
};

var Binop_greaterThan = {
  typ: /* GreaterThan */4,
  precedence: 12,
  associativity: /* LTR */0,
  fn: "(>)"
};

var Binop_greaterEqualThan = {
  typ: /* GreaterEqualThan */5,
  precedence: 12,
  associativity: /* LTR */0,
  fn: "(>=)"
};

var Binop_lessThan = {
  typ: /* LessThan */6,
  precedence: 12,
  associativity: /* LTR */0,
  fn: "(<)"
};

var Binop_lessEqualThan = {
  typ: /* LessEqualThan */7,
  precedence: 12,
  associativity: /* LTR */0,
  fn: "(<=)"
};

var Binop_addition = {
  typ: /* Addition */8,
  precedence: 14,
  associativity: /* LTR */0,
  fn: "(+)"
};

var Binop_substraction = {
  typ: /* Substraction */9,
  precedence: 14,
  associativity: /* LTR */0,
  fn: "(-)"
};

var Binop_multiplication = {
  typ: /* Multiplication */10,
  precedence: 15,
  associativity: /* LTR */0,
  fn: "(*)"
};

var Binop_division = {
  typ: /* Division */11,
  precedence: 15,
  associativity: /* LTR */0,
  fn: "(/)"
};

var Binop = {
  or: Binop_or,
  and_: Binop_and_,
  equal: Binop_equal,
  notEqual: Binop_notEqual,
  greaterThan: Binop_greaterThan,
  greaterEqualThan: Binop_greaterEqualThan,
  lessThan: Binop_lessThan,
  lessEqualThan: Binop_lessEqualThan,
  addition: Binop_addition,
  substraction: Binop_substraction,
  multiplication: Binop_multiplication,
  division: Binop_division
};

function toString(p) {
  return p._0;
}

var Pattern = {
  toString: toString
};

function toString$1(expr) {
  if (typeof expr === "number") {
    return "()";
  }
  switch (expr.TAG | 0) {
    case /* Bool */0 :
        if (expr._0) {
          return "true";
        } else {
          return "false";
        }
    case /* Float */1 :
        return String(expr._0);
    case /* String */2 :
        return "\"" + expr._0 + "\"";
    case /* Identifier */3 :
        return expr._0;
    case /* Unary */4 :
        if (expr._0.value) {
          return "-" + toString$1(expr._1.value);
        } else {
          return "!" + toString$1(expr._1.value);
        }
    case /* Binary */5 :
        var match = expr._1.value.typ;
        var opS;
        switch (match) {
          case /* Or */0 :
              opS = "||";
              break;
          case /* And */1 :
              opS = "&&";
              break;
          case /* Equal */2 :
              opS = "==";
              break;
          case /* NotEqual */3 :
              opS = "!=";
              break;
          case /* GreaterThan */4 :
              opS = ">";
              break;
          case /* GreaterEqualThan */5 :
              opS = ">=";
              break;
          case /* LessThan */6 :
              opS = "<";
              break;
          case /* LessEqualThan */7 :
              opS = "<=";
              break;
          case /* Addition */8 :
              opS = "+";
              break;
          case /* Substraction */9 :
              opS = "-";
              break;
          case /* Multiplication */10 :
              opS = "*";
              break;
          case /* Division */11 :
              opS = "/";
              break;
          
        }
        return "(" + toString$1(expr._0.value) + " " + opS + " " + toString$1(expr._2.value) + ")";
    case /* Lambda */6 :
        var paramsStr = Belt_Array.map(expr._0, (function (p) {
                  return p.value._0;
                })).join(", ");
        return "(" + paramsStr + ") => " + toString$1(expr._1.value);
    case /* FnCall */7 :
        return toString$1(expr._0.value) + "(" + toString$1(expr._1.value) + ")";
    case /* Let */8 :
        return "let " + expr._0 + " = (" + toString$1(expr._1.value) + "); " + toString$1(expr._2.value);
    
  }
}

var Expression = {
  toString: toString$1
};

var JsArray;

export {
  JsArray ,
  Binop ,
  Pattern ,
  Expression ,
  
}
/* No side effect */
