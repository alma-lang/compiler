// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Type from "./Type.js";
import * as TypeEnv from "./TypeEnv.js";
import * as Caml_obj from "../../../node_modules/rescript/lib/es6/caml_obj.js";
import * as Belt_List from "../../../node_modules/rescript/lib/es6/belt_List.js";
import * as Belt_MapString from "../../../node_modules/rescript/lib/es6/belt_MapString.js";
import * as Belt_HashMapInt from "../../../node_modules/rescript/lib/es6/belt_HashMapInt.js";
import * as Caml_exceptions from "../../../node_modules/rescript/lib/es6/caml_exceptions.js";

var $$TypeError = /* @__PURE__ */Caml_exceptions.create("Infer.TypeError");

function empty(param) {
  return {
          currentLevel: {
            contents: 1
          },
          currentTypeVar: {
            contents: 0
          }
        };
}

function enterLevel(state) {
  state.currentLevel.contents = state.currentLevel.contents + 1 | 0;
  
}

function exitLevel(state) {
  state.currentLevel.contents = state.currentLevel.contents - 1 | 0;
  
}

function newVar(state) {
  state.currentTypeVar.contents = state.currentTypeVar.contents + 1 | 0;
  return state.currentTypeVar.contents;
}

function newTypeVar(state) {
  return {
          TAG: 1,
          _0: {
            contents: {
              TAG: 1,
              _0: newVar(state),
              _1: state.currentLevel.contents,
              [Symbol.for("name")]: "Unbound"
            }
          },
          [Symbol.for("name")]: "Var"
        };
}

var State = {
  empty: empty,
  enterLevel: enterLevel,
  exitLevel: exitLevel,
  newVar: newVar,
  newTypeVar: newTypeVar
};

function inst(s, state) {
  var replaceTvs = function (tbl, _x) {
    while(true) {
      var x = _x;
      if (typeof x === "number") {
        return /* Unit */0;
      }
      switch (x.TAG | 0) {
        case /* Named */0 :
            return x;
        case /* Var */1 :
            var t = x._0.contents;
            if (t.TAG === /* Bound */0) {
              _x = t._0;
              continue ;
            }
            var t_ = Belt_HashMapInt.get(tbl, t._0);
            if (t_ !== undefined) {
              return t_;
            } else {
              return x;
            }
        case /* Fn */2 :
            return {
                    TAG: 2,
                    _0: replaceTvs(tbl, x._0),
                    _1: replaceTvs(tbl, x._1),
                    [Symbol.for("name")]: "Fn"
                  };
        case /* PolyType */3 :
            var tvs = x._0;
            var tblCpy = Belt_HashMapInt.copy(tbl);
            Belt_List.forEach(tvs, (function(tblCpy){
                return function (param) {
                  return Belt_HashMapInt.remove(tblCpy, param);
                }
                }(tblCpy)));
            return {
                    TAG: 3,
                    _0: tvs,
                    _1: replaceTvs(tblCpy, x._1),
                    [Symbol.for("name")]: "PolyType"
                  };
        
      }
    };
  };
  if (typeof s === "number") {
    return s;
  }
  if (s.TAG !== /* PolyType */3) {
    return s;
  }
  var tvsToReplace = Belt_HashMapInt.make(1);
  Belt_List.forEach(s._0, (function (tv) {
          return Belt_HashMapInt.set(tvsToReplace, tv, newTypeVar(state));
        }));
  return replaceTvs(tvsToReplace, s._1);
}

function occurs(aId, aLevel, _x) {
  while(true) {
    var x = _x;
    if (typeof x === "number") {
      return false;
    }
    switch (x.TAG | 0) {
      case /* Named */0 :
          return false;
      case /* Var */1 :
          var bTypevar = x._0;
          var t = bTypevar.contents;
          if (t.TAG === /* Bound */0) {
            _x = t._0;
            continue ;
          }
          var bId = t._0;
          var minLevel = aLevel < t._1 ? aLevel : t._1;
          bTypevar.contents = {
            TAG: 1,
            _0: bId,
            _1: minLevel,
            [Symbol.for("name")]: "Unbound"
          };
          return aId === bId;
      case /* Fn */2 :
          if (occurs(aId, aLevel, x._0)) {
            return true;
          }
          _x = x._1;
          continue ;
      case /* PolyType */3 :
          if (Belt_List.has(x._0, aId, (function (tv, aId) {
                    return aId === tv;
                  }))) {
            return false;
          }
          _x = x._1;
          continue ;
      
    }
  };
}

function unify(_t1, _t2) {
  while(true) {
    var t2 = _t2;
    var t1 = _t1;
    var exit = 0;
    var exit$1 = 0;
    if (typeof t1 === "number") {
      if (typeof t2 === "number") {
        return ;
      }
      if (t2.TAG === /* Var */1) {
        exit$1 = 3;
      } else {
        throw {
              RE_EXN_ID: $$TypeError,
              Error: new Error()
            };
      }
    } else {
      switch (t1.TAG | 0) {
        case /* Named */0 :
            if (typeof t2 === "number") {
              throw {
                    RE_EXN_ID: $$TypeError,
                    Error: new Error()
                  };
            }
            switch (t2.TAG | 0) {
              case /* Named */0 :
                  if (t1._0 !== t2._0) {
                    throw {
                          RE_EXN_ID: $$TypeError,
                          Error: new Error()
                        };
                  }
                  return Belt_List.forEach2U(t1._1, t2._1, unify);
              case /* Var */1 :
                  exit$1 = 3;
                  break;
              default:
                throw {
                      RE_EXN_ID: $$TypeError,
                      Error: new Error()
                    };
            }
            break;
        case /* Var */1 :
            var a$p = t1._0.contents;
            if (a$p.TAG === /* Bound */0) {
              _t1 = a$p._0;
              continue ;
            }
            exit$1 = 3;
            break;
        case /* Fn */2 :
            if (typeof t2 === "number") {
              throw {
                    RE_EXN_ID: $$TypeError,
                    Error: new Error()
                  };
            }
            switch (t2.TAG | 0) {
              case /* Var */1 :
                  exit$1 = 3;
                  break;
              case /* Fn */2 :
                  unify(t1._0, t2._0);
                  _t2 = t2._1;
                  _t1 = t1._1;
                  continue ;
              default:
                throw {
                      RE_EXN_ID: $$TypeError,
                      Error: new Error()
                    };
            }
            break;
        case /* PolyType */3 :
            if (typeof t2 === "number") {
              throw {
                    RE_EXN_ID: $$TypeError,
                    Error: new Error()
                  };
            }
            switch (t2.TAG | 0) {
              case /* Var */1 :
                  exit$1 = 3;
                  break;
              case /* PolyType */3 :
                  _t2 = t2._1;
                  _t1 = t1._1;
                  continue ;
              default:
                throw {
                      RE_EXN_ID: $$TypeError,
                      Error: new Error()
                    };
            }
            break;
        
      }
    }
    if (exit$1 === 3) {
      if (typeof t2 === "number" || t2.TAG !== /* Var */1) {
        exit = 2;
      } else {
        var b$p = t2._0.contents;
        if (b$p.TAG === /* Bound */0) {
          _t2 = b$p._0;
          continue ;
        }
        exit = 2;
      }
    }
    if (exit === 2 && typeof t1 !== "number" && t1.TAG === /* Var */1) {
      var a = t1._0;
      var match = a.contents;
      if (match.TAG !== /* Bound */0) {
        if (Caml_obj.caml_equal(t1, t2)) {
          return ;
        }
        if (occurs(match._0, match._1, t2)) {
          throw {
                RE_EXN_ID: $$TypeError,
                Error: new Error()
              };
        }
        a.contents = {
          TAG: 0,
          _0: t2,
          [Symbol.for("name")]: "Bound"
        };
        return ;
      }
      
    }
    if (typeof t2 === "number") {
      throw {
            RE_EXN_ID: $$TypeError,
            Error: new Error()
          };
    }
    if (t2.TAG === /* Var */1) {
      var b = t2._0;
      var match$1 = b.contents;
      if (match$1.TAG === /* Bound */0) {
        throw {
              RE_EXN_ID: $$TypeError,
              Error: new Error()
            };
      }
      if (Caml_obj.caml_equal(t1, t2)) {
        return ;
      }
      if (occurs(match$1._0, match$1._1, t1)) {
        throw {
              RE_EXN_ID: $$TypeError,
              Error: new Error()
            };
      }
      b.contents = {
        TAG: 0,
        _0: t1,
        [Symbol.for("name")]: "Bound"
      };
      return ;
    }
    throw {
          RE_EXN_ID: $$TypeError,
          Error: new Error()
        };
  };
}

function generalize(t, state) {
  var findAllTvs = function (_x) {
    while(true) {
      var x = _x;
      if (typeof x === "number") {
        return /* [] */0;
      }
      switch (x.TAG | 0) {
        case /* Named */0 :
            return Belt_List.concatMany(Belt_List.toArray(Belt_List.map(x._1, findAllTvs)));
        case /* Var */1 :
            var t = x._0.contents;
            if (t.TAG !== /* Bound */0) {
              if (t._1 > state.currentLevel.contents) {
                return {
                        hd: t._0,
                        tl: /* [] */0
                      };
              } else {
                return /* [] */0;
              }
            }
            _x = t._0;
            continue ;
        case /* Fn */2 :
            return Belt_List.concat(findAllTvs(x._0), findAllTvs(x._1));
        case /* PolyType */3 :
            var tvs = x._0;
            return Belt_List.keep(findAllTvs(x._1), (function(tvs){
                      return function (tv) {
                        return !Belt_List.has(tvs, tv, (function (a, b) {
                                      return a === b;
                                    }));
                      }
                      }(tvs)));
        
      }
    };
  };
  return {
          TAG: 3,
          _0: Belt_List.sort(findAllTvs(t), (function (a, b) {
                  return a - b | 0;
                })),
          _1: t,
          [Symbol.for("name")]: "PolyType"
        };
}

function infer(x) {
  var state_currentLevel = {
    contents: 1
  };
  var state_currentTypeVar = {
    contents: 0
  };
  var state = {
    currentLevel: state_currentLevel,
    currentTypeVar: state_currentTypeVar
  };
  var env = TypeEnv.empty(undefined);
  var inferRec = function (_env, _x) {
    while(true) {
      var x = _x;
      var env = _env;
      var x$1 = x.value;
      if (typeof x$1 === "number") {
        return /* Unit */0;
      }
      switch (x$1.TAG | 0) {
        case /* Bool */0 :
            return Type.bool_;
        case /* Number */1 :
            return Type.number;
        case /* String */2 :
            return Type.string_;
        case /* Identifier */3 :
            var s = TypeEnv.getExn(env, x$1._0);
            return inst(s, state);
        case /* Unary */4 :
            var t = inferRec(env, x$1._1);
            var match = x$1._0.value;
            if (match) {
              unify(t, Type.number);
            } else {
              unify(t, Type.bool_);
            }
            return t;
        case /* Binary */5 :
            var op = x$1._1;
            var left = x$1._0;
            var fnCall_value = {
              TAG: 7,
              _0: {
                value: {
                  TAG: 7,
                  _0: {
                    value: {
                      TAG: 3,
                      _0: op.value.fn,
                      [Symbol.for("name")]: "Identifier"
                    },
                    start: op.start,
                    end: op.end
                  },
                  _1: left,
                  [Symbol.for("name")]: "FnCall"
                },
                start: left.start,
                end: op.end
              },
              _1: x$1._2,
              [Symbol.for("name")]: "FnCall"
            };
            var fnCall_start = x.start;
            var fnCall_end = x.end;
            var fnCall = {
              value: fnCall_value,
              start: fnCall_start,
              end: fnCall_end
            };
            _x = fnCall;
            continue ;
        case /* Lambda */6 :
            var t$1 = newTypeVar(state);
            var t$p = inferRec(Belt_MapString.set(env, x$1._0, t$1), x$1._1);
            return {
                    TAG: 2,
                    _0: t$1,
                    _1: t$p,
                    [Symbol.for("name")]: "Fn"
                  };
        case /* FnCall */7 :
            var t0 = inferRec(env, x$1._0);
            var t1 = inferRec(env, x$1._1);
            var t$p$1 = newTypeVar(state);
            unify(t0, {
                  TAG: 2,
                  _0: t1,
                  _1: t$p$1,
                  [Symbol.for("name")]: "Fn"
                });
            return t$p$1;
        case /* Let */8 :
            state_currentLevel.contents = state_currentLevel.contents + 1 | 0;
            var t$2 = inferRec(env, x$1._1);
            state_currentLevel.contents = state_currentLevel.contents - 1 | 0;
            _x = x$1._2;
            _env = Belt_MapString.set(env, x$1._0, generalize(t$2, state));
            continue ;
        
      }
    };
  };
  return inferRec(env, x);
}

export {
  $$TypeError ,
  State ,
  inst ,
  occurs ,
  unify ,
  generalize ,
  infer ,
  
}
/* No side effect */
