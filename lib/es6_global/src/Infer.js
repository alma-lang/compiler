// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Ast from "./Ast.js";
import * as Type from "./Type.js";
import * as Input from "./Input.js";
import * as TypeEnv from "./TypeEnv.js";
import * as Caml_obj from "../../../node_modules/rescript/lib/es6/caml_obj.js";
import * as Belt_List from "../../../node_modules/rescript/lib/es6/belt_List.js";
import * as Belt_Array from "../../../node_modules/rescript/lib/es6/belt_Array.js";
import * as Belt_Option from "../../../node_modules/rescript/lib/es6/belt_Option.js";
import * as Belt_Result from "../../../node_modules/rescript/lib/es6/belt_Result.js";
import * as Belt_HashMapInt from "../../../node_modules/rescript/lib/es6/belt_HashMapInt.js";
import * as Caml_exceptions from "../../../node_modules/rescript/lib/es6/caml_exceptions.js";
import * as Caml_js_exceptions from "../../../node_modules/rescript/lib/es6/caml_js_exceptions.js";

var UnifyError = {};

var $$TypeError = /* @__PURE__ */Caml_exceptions.create("Infer.TypeError");

function toString(e, input) {
  var prefix;
  switch (e.TAG | 0) {
    case /* UndefinedIdentifier */0 :
        var match = e._0;
        prefix = "" + match.line + ":" + match.column;
        break;
    case /* TypeMismatch */1 :
        var match$1 = e._0;
        prefix = "" + match$1.line + ":" + match$1.column;
        break;
    case /* InfiniteType */2 :
        var match$2 = e._0;
        prefix = "" + match$2.line + ":" + match$2.column;
        break;
    
  }
  var match$3 = e._0;
  var code = Belt_Option.getWithDefault(Input.linesReportAtPositionWithPointer(match$3.start, match$3.line, match$3.end, input), "");
  var tmp;
  switch (e.TAG | 0) {
    case /* UndefinedIdentifier */0 :
        tmp = "Undefined identifier " + Ast.Expression.toString(e._0.value) + "\n\n" + code;
        break;
    case /* TypeMismatch */1 :
        var expr2 = e._2;
        var typ = e._1;
        if (expr2 !== undefined) {
          var code2 = Belt_Option.getWithDefault(Input.linesReportAtPositionWithPointer(expr2.start, expr2.line, expr2.end, input), "");
          var t1 = Type.toString(typ);
          var t2 = Type.toString(e._3);
          tmp = "Type mismatch:  " + t1 + "  ≠  " + t2 + "\n\nExpected\n\n" + code + "\n\nwith type\n\n" + t1 + "\n\nto have the same type as\n\n" + code2 + "\n\nwith type\n\n" + t2;
        } else {
          var t1$1 = Type.toString(typ);
          var t2$1 = Type.toString(e._3);
          tmp = "Type mismatch:  " + t1$1 + "  ≠  " + t2$1 + "\n\nExpected\n\n" + code + "\n\nto be\n\n" + t2$1 + "\n\nbut seems to be\n\n" + t1$1;
        }
        break;
    case /* InfiniteType */2 :
        tmp = "Infinite type\n\n" + code;
        break;
    
  }
  return "" + prefix + ": " + tmp;
}

function toStringMany(errors, input) {
  return Belt_Array.joinWith(errors, "\n\n----------------------------------------\n\n", (function (error) {
                return toString(error, input);
              }));
}

var InferError = {
  toString: toString,
  toStringMany: toStringMany
};

function empty(param) {
  return {
          currentLevel: {
            contents: 1
          },
          currentTypeVar: {
            contents: 0
          }
        };
}

function enterLevel(state) {
  state.currentLevel.contents = state.currentLevel.contents + 1 | 0;
  
}

function exitLevel(state) {
  state.currentLevel.contents = state.currentLevel.contents - 1 | 0;
  
}

function newVar(state) {
  state.currentTypeVar.contents = state.currentTypeVar.contents + 1 | 0;
  return state.currentTypeVar.contents;
}

function newTypeVar(state) {
  return {
          TAG: 1,
          _0: {
            contents: {
              TAG: 1,
              _0: newVar(state),
              _1: state.currentLevel.contents,
              [Symbol.for("name")]: "Unbound"
            }
          },
          [Symbol.for("name")]: "Var"
        };
}

var State = {
  empty: empty,
  enterLevel: enterLevel,
  exitLevel: exitLevel,
  newVar: newVar,
  newTypeVar: newTypeVar
};

function inst(s, state) {
  var replaceTvs = function (tbl, _x) {
    while(true) {
      var x = _x;
      if (typeof x === "number") {
        return /* Unit */0;
      }
      switch (x.TAG | 0) {
        case /* Named */0 :
            return x;
        case /* Var */1 :
            var t = x._0.contents;
            if (t.TAG === /* Bound */0) {
              _x = t._0;
              continue ;
            }
            var t_ = Belt_HashMapInt.get(tbl, t._0);
            if (t_ !== undefined) {
              return t_;
            } else {
              return x;
            }
        case /* Fn */2 :
            return {
                    TAG: 2,
                    _0: replaceTvs(tbl, x._0),
                    _1: replaceTvs(tbl, x._1),
                    [Symbol.for("name")]: "Fn"
                  };
        case /* PolyType */3 :
            var tvs = x._0;
            var tblCpy = Belt_HashMapInt.copy(tbl);
            Belt_List.forEach(tvs, (function(tblCpy){
                return function (param) {
                  return Belt_HashMapInt.remove(tblCpy, param);
                }
                }(tblCpy)));
            return {
                    TAG: 3,
                    _0: tvs,
                    _1: replaceTvs(tblCpy, x._1),
                    [Symbol.for("name")]: "PolyType"
                  };
        
      }
    };
  };
  if (typeof s === "number") {
    return s;
  }
  if (s.TAG !== /* PolyType */3) {
    return s;
  }
  var tvsToReplace = Belt_HashMapInt.make(1);
  Belt_List.forEach(s._0, (function (tv) {
          return Belt_HashMapInt.set(tvsToReplace, tv, newTypeVar(state));
        }));
  return replaceTvs(tvsToReplace, s._1);
}

function occurs(aId, aLevel, _x) {
  while(true) {
    var x = _x;
    if (typeof x === "number") {
      return false;
    }
    switch (x.TAG | 0) {
      case /* Named */0 :
          return false;
      case /* Var */1 :
          var bTypevar = x._0;
          var t = bTypevar.contents;
          if (t.TAG === /* Bound */0) {
            _x = t._0;
            continue ;
          }
          var bId = t._0;
          var minLevel = aLevel < t._1 ? aLevel : t._1;
          bTypevar.contents = {
            TAG: 1,
            _0: bId,
            _1: minLevel,
            [Symbol.for("name")]: "Unbound"
          };
          return aId === bId;
      case /* Fn */2 :
          if (occurs(aId, aLevel, x._0)) {
            return true;
          }
          _x = x._1;
          continue ;
      case /* PolyType */3 :
          if (Belt_List.has(x._0, aId, (function (tv, aId) {
                    return aId === tv;
                  }))) {
            return false;
          }
          _x = x._1;
          continue ;
      
    }
  };
}

function unify(ast, t1, ast2, t2) {
  var unifyExn = function (_t1, _t2) {
    while(true) {
      var t2 = _t2;
      var t1 = _t1;
      var exit = 0;
      var exit$1 = 0;
      if (typeof t1 === "number") {
        if (typeof t2 === "number") {
          return ;
        }
        if (t2.TAG === /* Var */1) {
          exit$1 = 3;
        } else {
          throw {
                RE_EXN_ID: $$TypeError,
                _1: /* TypeMismatch */0,
                Error: new Error()
              };
        }
      } else {
        switch (t1.TAG | 0) {
          case /* Named */0 :
              if (typeof t2 === "number") {
                throw {
                      RE_EXN_ID: $$TypeError,
                      _1: /* TypeMismatch */0,
                      Error: new Error()
                    };
              }
              switch (t2.TAG | 0) {
                case /* Named */0 :
                    if (t1._0 !== t2._0) {
                      throw {
                            RE_EXN_ID: $$TypeError,
                            _1: /* TypeMismatch */0,
                            Error: new Error()
                          };
                    }
                    return Belt_List.forEach2(t1._1, t2._1, unifyExn);
                case /* Var */1 :
                    exit$1 = 3;
                    break;
                default:
                  throw {
                        RE_EXN_ID: $$TypeError,
                        _1: /* TypeMismatch */0,
                        Error: new Error()
                      };
              }
              break;
          case /* Var */1 :
              var a$p = t1._0.contents;
              if (a$p.TAG === /* Bound */0) {
                _t1 = a$p._0;
                continue ;
              }
              exit$1 = 3;
              break;
          case /* Fn */2 :
              if (typeof t2 === "number") {
                throw {
                      RE_EXN_ID: $$TypeError,
                      _1: /* TypeMismatch */0,
                      Error: new Error()
                    };
              }
              switch (t2.TAG | 0) {
                case /* Var */1 :
                    exit$1 = 3;
                    break;
                case /* Fn */2 :
                    unifyExn(t1._0, t2._0);
                    _t2 = t2._1;
                    _t1 = t1._1;
                    continue ;
                default:
                  throw {
                        RE_EXN_ID: $$TypeError,
                        _1: /* TypeMismatch */0,
                        Error: new Error()
                      };
              }
              break;
          case /* PolyType */3 :
              if (typeof t2 === "number") {
                throw {
                      RE_EXN_ID: $$TypeError,
                      _1: /* TypeMismatch */0,
                      Error: new Error()
                    };
              }
              switch (t2.TAG | 0) {
                case /* Var */1 :
                    exit$1 = 3;
                    break;
                case /* PolyType */3 :
                    _t2 = t2._1;
                    _t1 = t1._1;
                    continue ;
                default:
                  throw {
                        RE_EXN_ID: $$TypeError,
                        _1: /* TypeMismatch */0,
                        Error: new Error()
                      };
              }
              break;
          
        }
      }
      if (exit$1 === 3) {
        if (typeof t2 === "number" || t2.TAG !== /* Var */1) {
          exit = 2;
        } else {
          var b$p = t2._0.contents;
          if (b$p.TAG === /* Bound */0) {
            _t2 = b$p._0;
            continue ;
          }
          exit = 2;
        }
      }
      if (exit === 2 && typeof t1 !== "number" && t1.TAG === /* Var */1) {
        var a = t1._0;
        var match = a.contents;
        if (match.TAG !== /* Bound */0) {
          if (Caml_obj.caml_equal(t1, t2)) {
            return ;
          }
          if (occurs(match._0, match._1, t2)) {
            throw {
                  RE_EXN_ID: $$TypeError,
                  _1: /* InfiniteType */1,
                  Error: new Error()
                };
          }
          a.contents = {
            TAG: 0,
            _0: t2,
            [Symbol.for("name")]: "Bound"
          };
          return ;
        }
        
      }
      if (typeof t2 === "number") {
        throw {
              RE_EXN_ID: $$TypeError,
              _1: /* TypeMismatch */0,
              Error: new Error()
            };
      }
      if (t2.TAG === /* Var */1) {
        var b = t2._0;
        var match$1 = b.contents;
        if (match$1.TAG === /* Bound */0) {
          throw {
                RE_EXN_ID: $$TypeError,
                _1: /* TypeMismatch */0,
                Error: new Error()
              };
        }
        if (Caml_obj.caml_equal(t1, t2)) {
          return ;
        }
        if (occurs(match$1._0, match$1._1, t1)) {
          throw {
                RE_EXN_ID: $$TypeError,
                _1: /* InfiniteType */1,
                Error: new Error()
              };
        }
        b.contents = {
          TAG: 0,
          _0: t1,
          [Symbol.for("name")]: "Bound"
        };
        return ;
      }
      throw {
            RE_EXN_ID: $$TypeError,
            _1: /* TypeMismatch */0,
            Error: new Error()
          };
    };
  };
  try {
    return {
            TAG: 0,
            _0: unifyExn(t1, t2),
            [Symbol.for("name")]: "Ok"
          };
  }
  catch (raw_e){
    var e = Caml_js_exceptions.internalToOCamlException(raw_e);
    if (e.RE_EXN_ID === $$TypeError) {
      return {
              TAG: 1,
              _0: e._1 ? ({
                    TAG: 2,
                    _0: ast,
                    _1: t1,
                    [Symbol.for("name")]: "InfiniteType"
                  }) : ({
                    TAG: 1,
                    _0: ast,
                    _1: t1,
                    _2: ast2,
                    _3: t2,
                    [Symbol.for("name")]: "TypeMismatch"
                  }),
              [Symbol.for("name")]: "Error"
            };
    }
    throw e;
  }
}

function generalize(t, state) {
  var findAllTvs = function (_x) {
    while(true) {
      var x = _x;
      if (typeof x === "number") {
        return /* [] */0;
      }
      switch (x.TAG | 0) {
        case /* Named */0 :
            return Belt_List.concatMany(Belt_List.toArray(Belt_List.map(x._1, findAllTvs)));
        case /* Var */1 :
            var t = x._0.contents;
            if (t.TAG !== /* Bound */0) {
              if (t._1 > state.currentLevel.contents) {
                return {
                        hd: t._0,
                        tl: /* [] */0
                      };
              } else {
                return /* [] */0;
              }
            }
            _x = t._0;
            continue ;
        case /* Fn */2 :
            return Belt_List.concat(findAllTvs(x._0), findAllTvs(x._1));
        case /* PolyType */3 :
            var tvs = x._0;
            return Belt_List.keep(findAllTvs(x._1), (function(tvs){
                      return function (tv) {
                        return !Belt_List.has(tvs, tv, (function (a, b) {
                                      return a === b;
                                    }));
                      }
                      }(tvs)));
        
      }
    };
  };
  return {
          TAG: 3,
          _0: Belt_List.sort(findAllTvs(t), (function (a, b) {
                  return a - b | 0;
                })),
          _1: t,
          [Symbol.for("name")]: "PolyType"
        };
}

function infer(ast) {
  var state_currentLevel = {
    contents: 1
  };
  var state_currentTypeVar = {
    contents: 0
  };
  var state = {
    currentLevel: state_currentLevel,
    currentTypeVar: state_currentTypeVar
  };
  var env = TypeEnv.empty((function (param) {
          return newTypeVar(state);
        }), (function (t) {
          return generalize(t, state);
        }));
  var errors = [];
  var addError = function (r) {
    if (r.TAG === /* Ok */0) {
      return ;
    }
    errors.push(r._0);
    
  };
  var inferRec = function (_env, _ast) {
    while(true) {
      var ast = _ast;
      var env = _env;
      var x = ast.value;
      if (typeof x === "number") {
        return /* Unit */0;
      }
      switch (x.TAG | 0) {
        case /* Bool */0 :
            return Type.bool_;
        case /* Float */1 :
            return Type.float_;
        case /* String */2 :
            return Type.string_;
        case /* Identifier */3 :
            var s = TypeEnv.get(env, x._0);
            if (s !== undefined) {
              return inst(s, state);
            } else {
              addError({
                    TAG: 1,
                    _0: {
                      TAG: 0,
                      _0: ast,
                      [Symbol.for("name")]: "UndefinedIdentifier"
                    },
                    [Symbol.for("name")]: "Error"
                  });
              return newTypeVar(state);
            }
        case /* Unary */4 :
            var e = x._1;
            var t = inferRec(env, e);
            var match = x._0.value;
            addError(match ? unify(e, t, undefined, Type.float_) : unify(e, t, undefined, Type.bool_));
            return t;
        case /* Binary */5 :
            var op = x._1;
            var fnCall_value = {
              TAG: 7,
              _0: {
                value: {
                  TAG: 3,
                  _0: op.value.fn,
                  [Symbol.for("name")]: "Identifier"
                },
                line: op.line,
                column: op.column,
                start: op.start,
                end: op.end
              },
              _1: [
                x._0,
                x._2
              ],
              [Symbol.for("name")]: "FnCall"
            };
            var fnCall_line = ast.line;
            var fnCall_column = ast.column;
            var fnCall_start = ast.start;
            var fnCall_end = ast.end;
            var fnCall = {
              value: fnCall_value,
              line: fnCall_line,
              column: fnCall_column,
              start: fnCall_start,
              end: fnCall_end
            };
            _ast = fnCall;
            continue ;
        case /* Lambda */6 :
            var paramsWithType = Belt_Array.map(x._0, (function (p) {
                    return [
                            p,
                            newTypeVar(state)
                          ];
                  }));
            var env$1 = Belt_Array.reduce(paramsWithType, env, (function (env, param) {
                    return TypeEnv.set(env, param[0].value._0, param[1]);
                  }));
            var returnType = inferRec(env$1, x._1);
            return Belt_Array.reduceReverse(paramsWithType, returnType, (function (returnType, param) {
                          return {
                                  TAG: 2,
                                  _0: param[1],
                                  _1: returnType,
                                  [Symbol.for("name")]: "Fn"
                                };
                        }));
        case /* FnCall */7 :
            var fnType = inferRec(env, x._0);
            var paramTypes = Type.parameters(fnType);
            var argsWithTypes = Belt_Array.map(x._1, (function(env){
                return function (arg) {
                  return [
                          arg,
                          inferRec(env, arg)
                        ];
                }
                }(env)));
            var returnType$1 = newTypeVar(state);
            var callType = Belt_Array.reduceReverse(argsWithTypes, returnType$1, (function (returnType, param) {
                    return {
                            TAG: 2,
                            _0: param[1],
                            _1: returnType,
                            [Symbol.for("name")]: "Fn"
                          };
                  }));
            addError(Belt_Result.flatMap(Belt_Array.reduce(Belt_Array.zip(argsWithTypes, paramTypes), {
                          TAG: 0,
                          _0: undefined,
                          [Symbol.for("name")]: "Ok"
                        }, (function (result, param) {
                            var paramType = param[1];
                            var match = param[0];
                            var argType = match[1];
                            var arg = match[0];
                            return Belt_Result.flatMap(result, (function (param) {
                                          return unify(arg, argType, undefined, paramType);
                                        }));
                          })), (function(ast,fnType,callType){
                    return function (param) {
                      return unify(ast, callType, undefined, fnType);
                    }
                    }(ast,fnType,callType))));
            return returnType$1;
        case /* Let */8 :
            state_currentLevel.contents = state_currentLevel.contents + 1 | 0;
            var t$1 = inferRec(env, x._1);
            state_currentLevel.contents = state_currentLevel.contents - 1 | 0;
            var x$1 = x._0.value;
            var env$2 = TypeEnv.set(env, x$1._0, generalize(t$1, state));
            _ast = x._2;
            _env = env$2;
            continue ;
        case /* If */9 :
            var else_ = x._2;
            var $$then = x._1;
            var condition = x._0;
            var t$2 = inferRec(env, condition);
            addError(unify(condition, t$2, undefined, Type.bool_));
            var t1 = inferRec(env, $$then);
            var t2 = inferRec(env, else_);
            addError(unify($$then, t1, else_, t2));
            return t2;
        
      }
    };
  };
  var t = inferRec(env, ast);
  var match = errors.length;
  if (match !== 0) {
    return {
            TAG: 1,
            _0: errors,
            [Symbol.for("name")]: "Error"
          };
  } else {
    return {
            TAG: 0,
            _0: t,
            [Symbol.for("name")]: "Ok"
          };
  }
}

export {
  UnifyError ,
  $$TypeError ,
  InferError ,
  State ,
  inst ,
  occurs ,
  unify ,
  generalize ,
  infer ,
  
}
/* No side effect */
