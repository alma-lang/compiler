// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Ast from "./Ast.js";
import * as $$Node from "./Node.js";
import * as Input from "./Input.js";
import * as Js_exn from "../../../node_modules/rescript/lib/es6/js_exn.js";
import * as Belt_Array from "../../../node_modules/rescript/lib/es6/belt_Array.js";
import * as Belt_Float from "../../../node_modules/rescript/lib/es6/belt_Float.js";
import * as Belt_Option from "../../../node_modules/rescript/lib/es6/belt_Option.js";
import * as Belt_Result from "../../../node_modules/rescript/lib/es6/belt_Result.js";

function make(input, token, pointAtToken, message) {
  var pointAtToken$1 = Belt_Option.getWithDefault(pointAtToken, token);
  var position = pointAtToken$1.position;
  var lineNumber = pointAtToken$1.line;
  var columnNumber = pointAtToken$1.column;
  var message$1 = String(token.line) + ":" + String(token.column) + ": " + message + "\n\n" + Belt_Option.getWithDefault(Input.linesReportAtPositionWithPointer(input, position, lineNumber, columnNumber), "");
  return {
          message: message$1,
          token: token
        };
}

function expectedButFound(input, token, pointAtToken, message) {
  return make(input, token, pointAtToken, message + ", but instead found: '" + token.lexeme + "'");
}

var ParseError = {
  make: make,
  expectedButFound: expectedButFound
};

function getToken(parser) {
  var token = Belt_Array.get(parser.tokens, parser.current);
  if (token !== undefined) {
    return token;
  } else {
    return Js_exn.raiseTypeError("Out of bounds access to tokens array");
  }
}

function advance(parser) {
  var token = getToken(parser);
  if (token.kind !== /* Eof */38) {
    parser.current = parser.current + 1 | 0;
  }
  return parser;
}

function organizeBinops(left, binops, current, minPrecedence) {
  var left$1 = left;
  var outerBreak = false;
  while(!outerBreak) {
    var match = Belt_Array.get(binops, current.contents);
    if (match !== undefined) {
      var op = match[0];
      if (op.value.precedence >= minPrecedence) {
        current.contents = current.contents + 1 | 0;
        var nextMinPrecedence = op.value.precedence + (
          op.value.associativity === /* LTR */0 ? 1 : 0
        ) | 0;
        var right = organizeBinops(match[1], binops, current, nextMinPrecedence);
        left$1 = {
          value: {
            TAG: 5,
            _0: left$1,
            _1: op,
            _2: right,
            [Symbol.for("name")]: "Binary"
          },
          start: left$1.start,
          end: right.end
        };
      } else {
        outerBreak = true;
      }
    } else {
      outerBreak = true;
    }
  };
  return left$1;
}

function binary(parser) {
  return Belt_Result.flatMap(unary(parser), (function (expr) {
                return Belt_Result.map(binaryStep(parser, []), (function (binops) {
                              return organizeBinops(expr, binops, {
                                          contents: 0
                                        }, 0);
                            }));
              }));
}

function unary(parser) {
  var token = getToken(parser);
  var match = token.kind;
  var u = match !== 6 ? (
      match !== 25 ? undefined : (advance(parser), /* Not */0)
    ) : (advance(parser), /* Minus */1);
  return Belt_Result.flatMap(call(parser), (function (expr) {
                if (u === undefined) {
                  return {
                          TAG: 0,
                          _0: expr,
                          [Symbol.for("name")]: "Ok"
                        };
                }
                var op = $$Node.make(u, token, token);
                return {
                        TAG: 0,
                        _0: {
                          value: {
                            TAG: 4,
                            _0: op,
                            _1: expr,
                            [Symbol.for("name")]: "Unary"
                          },
                          start: op.start,
                          end: expr.end
                        },
                        [Symbol.for("name")]: "Ok"
                      };
              }));
}

function binaryStep(parser, binops) {
  var token = getToken(parser);
  var match = token.kind;
  var op;
  switch (match) {
    case /* Minus */6 :
        op = Ast.Binop.substraction;
        break;
    case /* Plus */7 :
        op = Ast.Binop.addition;
        break;
    case /* Slash */10 :
        op = Ast.Binop.division;
        break;
    case /* Star */11 :
        op = Ast.Binop.multiplication;
        break;
    case /* BangEqual */13 :
        op = Ast.Binop.notEqual;
        break;
    case /* EqualEqual */15 :
        op = Ast.Binop.equal;
        break;
    case /* Greater */16 :
        op = Ast.Binop.greaterThan;
        break;
    case /* GreaterEqual */17 :
        op = Ast.Binop.greaterEqualThan;
        break;
    case /* Less */18 :
        op = Ast.Binop.lessThan;
        break;
    case /* LessEqual */19 :
        op = Ast.Binop.lessEqualThan;
        break;
    case /* And */23 :
        op = Ast.Binop.and_;
        break;
    case /* Or */24 :
        op = Ast.Binop.or;
        break;
    case /* LeftParen */0 :
    case /* RightParen */1 :
    case /* LeftBrace */2 :
    case /* RightBrace */3 :
    case /* Comma */4 :
    case /* Dot */5 :
    case /* Semicolon */8 :
    case /* Colon */9 :
    case /* Bang */12 :
    case /* Equal */14 :
    case /* Identifier */20 :
    case /* String */21 :
    case /* Number */22 :
    case /* Not */25 :
    case /* If */26 :
    case /* Then */27 :
    case /* Else */28 :
    case /* True */29 :
    case /* False */30 :
    case /* Fun */31 :
    case /* Let */32 :
    case /* Import */33 :
    case /* As */34 :
    case /* Exports */35 :
    case /* Module */36 :
    case /* Comment */37 :
    case /* Eof */38 :
        op = undefined;
        break;
    
  }
  if (op === undefined) {
    return {
            TAG: 0,
            _0: binops,
            [Symbol.for("name")]: "Ok"
          };
  }
  var opNode = $$Node.make(op, token, token);
  return Belt_Result.flatMap(unary(advance(parser)), (function (right) {
                binops.push([
                      opNode,
                      right
                    ]);
                return binaryStep(parser, binops);
              }));
}

function primary(parser) {
  var token = getToken(parser);
  var match = token.kind;
  var result;
  if (match >= 20) {
    if (match >= 31) {
      result = {
        TAG: 0,
        _0: undefined,
        [Symbol.for("name")]: "Ok"
      };
    } else {
      switch (match) {
        case /* Identifier */20 :
            result = {
              TAG: 0,
              _0: $$Node.make({
                    TAG: 3,
                    _0: token.lexeme,
                    [Symbol.for("name")]: "Identifier"
                  }, token, token),
              [Symbol.for("name")]: "Ok"
            };
            break;
        case /* String */21 :
            var value = token.lexeme.substring(1, token.lexeme.length - 1 | 0);
            result = {
              TAG: 0,
              _0: $$Node.make({
                    TAG: 2,
                    _0: value,
                    [Symbol.for("name")]: "String"
                  }, token, token),
              [Symbol.for("name")]: "Ok"
            };
            break;
        case /* Number */22 :
            var n = Belt_Float.fromString(token.lexeme);
            result = n !== undefined ? ({
                  TAG: 0,
                  _0: $$Node.make({
                        TAG: 1,
                        _0: n,
                        [Symbol.for("name")]: "Number"
                      }, token, token),
                  [Symbol.for("name")]: "Ok"
                }) : ({
                  TAG: 1,
                  _0: make(parser.input, token, undefined, "Failed to parse number token '" + token.lexeme + "'"),
                  [Symbol.for("name")]: "Error"
                });
            break;
        case /* And */23 :
        case /* Or */24 :
        case /* Not */25 :
        case /* If */26 :
        case /* Then */27 :
        case /* Else */28 :
            result = {
              TAG: 0,
              _0: undefined,
              [Symbol.for("name")]: "Ok"
            };
            break;
        case /* True */29 :
            result = {
              TAG: 0,
              _0: $$Node.make({
                    TAG: 0,
                    _0: true,
                    [Symbol.for("name")]: "Bool"
                  }, token, token),
              [Symbol.for("name")]: "Ok"
            };
            break;
        case /* False */30 :
            result = {
              TAG: 0,
              _0: $$Node.make({
                    TAG: 0,
                    _0: false,
                    [Symbol.for("name")]: "Bool"
                  }, token, token),
              [Symbol.for("name")]: "Ok"
            };
            break;
        
      }
    }
  } else {
    result = match !== 0 ? ({
          TAG: 0,
          _0: undefined,
          [Symbol.for("name")]: "Ok"
        }) : Belt_Result.flatMap(binary(advance(parser)), (function (expr) {
              var lastToken = getToken(parser);
              var match = lastToken.kind;
              if (match !== 1) {
                return {
                        TAG: 1,
                        _0: expectedButFound(parser.input, lastToken, token, "Expected ')' after parenthesized expression"),
                        [Symbol.for("name")]: "Error"
                      };
              } else {
                return {
                        TAG: 0,
                        _0: expr,
                        [Symbol.for("name")]: "Ok"
                      };
              }
            }));
  }
  if (result.TAG === /* Ok */0) {
    if (result._0 !== undefined) {
      advance(parser);
    }
    
  }
  return result;
}

function callStep(parser, returnExpr) {
  return Belt_Result.flatMap(primary(parser), (function (arg) {
                if (arg !== undefined) {
                  return callStep(parser, {
                              value: {
                                TAG: 7,
                                _0: returnExpr,
                                _1: arg,
                                [Symbol.for("name")]: "FnCall"
                              },
                              start: returnExpr.start,
                              end: arg.end
                            });
                } else {
                  return {
                          TAG: 0,
                          _0: returnExpr,
                          [Symbol.for("name")]: "Ok"
                        };
                }
              }));
}

function call(parser) {
  return Belt_Result.flatMap(primary(parser), (function (expr) {
                if (expr !== undefined) {
                  return callStep(parser, expr);
                } else {
                  return {
                          TAG: 1,
                          _0: expectedButFound(parser.input, getToken(parser), undefined, "Expected an expression (let binding, function call, an identifier, etc.)"),
                          [Symbol.for("name")]: "Error"
                        };
                }
              }));
}

var expression = binary;

function file(parser) {
  var result = binary(parser);
  if (result.TAG !== /* Ok */0) {
    return {
            TAG: 1,
            _0: [result._0],
            [Symbol.for("name")]: "Error"
          };
  }
  var token = getToken(parser);
  if (token.kind >= 38) {
    return {
            TAG: 0,
            _0: result._0,
            [Symbol.for("name")]: "Ok"
          };
  } else {
    return {
            TAG: 1,
            _0: [expectedButFound(parser.input, token, undefined, "Expected the end of input")],
            [Symbol.for("name")]: "Error"
          };
  }
}

function parse(input, tokens) {
  return file({
              input: input,
              tokens: tokens,
              current: 0
            });
}

var $$String$1;

var JsArray;

export {
  $$String$1 as $$String,
  JsArray ,
  ParseError ,
  getToken ,
  advance ,
  organizeBinops ,
  expression ,
  binary ,
  binaryStep ,
  unary ,
  call ,
  callStep ,
  primary ,
  file ,
  parse ,
  
}
/* No side effect */
