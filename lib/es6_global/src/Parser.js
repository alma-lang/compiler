// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Ast from "./Ast.js";
import * as $$Node from "./Node.js";
import * as Input from "./Input.js";
import * as Js_exn from "../../../node_modules/rescript/lib/es6/js_exn.js";
import * as Belt_Array from "../../../node_modules/rescript/lib/es6/belt_Array.js";
import * as Belt_Float from "../../../node_modules/rescript/lib/es6/belt_Float.js";
import * as Belt_Option from "../../../node_modules/rescript/lib/es6/belt_Option.js";
import * as Belt_Result from "../../../node_modules/rescript/lib/es6/belt_Result.js";

function make(input, token, pointAtToken, message) {
  var pointAtToken$1 = Belt_Option.getWithDefault(pointAtToken, token);
  var position = pointAtToken$1.position;
  var end = pointAtToken$1.position + pointAtToken$1.lexeme.length | 0;
  var lineNumber = pointAtToken$1.line;
  var message$1 = String(token.line) + ":" + String(token.column) + ": " + message + "\n\n" + Belt_Option.getWithDefault(Input.linesReportAtPositionWithPointer(position, lineNumber, end, input), "");
  return {
          message: message$1,
          token: token
        };
}

function expectedButFound(input, token, pointAtToken, message) {
  return make(input, token, pointAtToken, message + ", but instead found: '" + token.lexeme + "'");
}

var ParseError = {
  make: make,
  expectedButFound: expectedButFound
};

function getToken(parser) {
  var token = Belt_Array.get(parser.tokens, parser.current);
  if (token !== undefined) {
    return token;
  } else {
    return Js_exn.raiseTypeError("Out of bounds access to tokens array");
  }
}

function advance(parser) {
  var token = getToken(parser);
  if (token.kind !== /* Eof */39) {
    parser.current = parser.current + 1 | 0;
  }
  return parser;
}

function organizeBinops(left, binops, current, minPrecedence) {
  var left$1 = left;
  var outerBreak = false;
  while(!outerBreak) {
    var match = Belt_Array.get(binops, current.contents);
    if (match !== undefined) {
      var op = match[0];
      if (op.value.precedence >= minPrecedence) {
        current.contents = current.contents + 1 | 0;
        var nextMinPrecedence = op.value.precedence + (
          op.value.associativity === /* LTR */0 ? 1 : 0
        ) | 0;
        var right = organizeBinops(match[1], binops, current, nextMinPrecedence);
        left$1 = {
          value: {
            TAG: 5,
            _0: left$1,
            _1: op,
            _2: right,
            [Symbol.for("name")]: "Binary"
          },
          line: left$1.line,
          column: left$1.column,
          start: left$1.start,
          end: right.end
        };
      } else {
        outerBreak = true;
      }
    } else {
      outerBreak = true;
    }
  };
  return left$1;
}

function isNestedIndent(parser, parentToken) {
  var token = getToken(parser);
  if (parentToken.line === token.line) {
    return true;
  } else if (parentToken.line < token.line) {
    return token.indent > parentToken.indent;
  } else {
    return false;
  }
}

function isNextLineSameIndent(parser, parentToken) {
  var token = getToken(parser);
  if (parentToken.line < token.line) {
    return token.indent === parentToken.indent;
  } else {
    return false;
  }
}

function expression(parser) {
  var e = lambda(parser);
  if (e.TAG !== /* Ok */0) {
    return {
            TAG: 1,
            _0: e._0,
            [Symbol.for("name")]: "Error"
          };
  }
  var lambda$1 = e._0;
  if (lambda$1 !== undefined) {
    return {
            TAG: 0,
            _0: lambda$1,
            [Symbol.for("name")]: "Ok"
          };
  }
  var e$1 = if_(parser);
  if (e$1.TAG !== /* Ok */0) {
    return {
            TAG: 1,
            _0: e$1._0,
            [Symbol.for("name")]: "Error"
          };
  }
  var if_$1 = e$1._0;
  if (if_$1 !== undefined) {
    return {
            TAG: 0,
            _0: if_$1,
            [Symbol.for("name")]: "Ok"
          };
  }
  var e$2 = let_(parser);
  if (e$2.TAG !== /* Ok */0) {
    return {
            TAG: 1,
            _0: e$2._0,
            [Symbol.for("name")]: "Error"
          };
  }
  var let_$1 = e$2._0;
  if (let_$1 !== undefined) {
    return {
            TAG: 0,
            _0: let_$1,
            [Symbol.for("name")]: "Ok"
          };
  } else {
    return binary(parser);
  }
}

function let_(parser) {
  var token = getToken(parser);
  var match = token.kind;
  if (match !== 33) {
    return {
            TAG: 0,
            _0: undefined,
            [Symbol.for("name")]: "Ok"
          };
  } else {
    return Belt_Result.flatMap(pattern(advance(parser)), (function (pattern) {
                  if (pattern === undefined) {
                    return {
                            TAG: 1,
                            _0: expectedButFound(parser.input, getToken(parser), undefined, "Expected a pattern for the left side of the let expression"),
                            [Symbol.for("name")]: "Error"
                          };
                  }
                  var match = getToken(parser).kind;
                  if (match !== 15) {
                    return {
                            TAG: 1,
                            _0: expectedButFound(parser.input, getToken(parser), undefined, "Expected an = and an expression for the right side of let expression"),
                            [Symbol.for("name")]: "Error"
                          };
                  } else {
                    return Belt_Result.flatMap(expression(advance(parser)), (function (value) {
                                  if (isNextLineSameIndent(parser, token)) {
                                    return Belt_Result.map(expression(parser), (function (body) {
                                                  return {
                                                          value: {
                                                            TAG: 8,
                                                            _0: pattern,
                                                            _1: value,
                                                            _2: body,
                                                            [Symbol.for("name")]: "Let"
                                                          },
                                                          line: token.line,
                                                          column: token.column,
                                                          start: token.position,
                                                          end: body.end
                                                        };
                                                }));
                                  } else {
                                    return {
                                            TAG: 1,
                                            _0: expectedButFound(parser.input, getToken(parser), undefined, "Expected the let definition to be followed by another let or expression in the next line and same indentation"),
                                            [Symbol.for("name")]: "Error"
                                          };
                                  }
                                }));
                  }
                }));
  }
}

function if_(parser) {
  var token = getToken(parser);
  var match = token.kind;
  if (match !== 28) {
    return {
            TAG: 0,
            _0: undefined,
            [Symbol.for("name")]: "Ok"
          };
  } else {
    return Belt_Result.flatMap(binary(advance(parser)), (function (condition) {
                  var match = getToken(parser).kind;
                  if (match !== 29) {
                    return {
                            TAG: 1,
                            _0: expectedButFound(parser.input, getToken(parser), undefined, "Expected the keyword `then` and an expression to parse the if expression"),
                            [Symbol.for("name")]: "Error"
                          };
                  } else {
                    return Belt_Result.flatMap(expression(advance(parser)), (function ($$then) {
                                  var match = getToken(parser).kind;
                                  if (match !== 30) {
                                    return {
                                            TAG: 1,
                                            _0: expectedButFound(parser.input, getToken(parser), undefined, "Expected the `else` branch of the if expression"),
                                            [Symbol.for("name")]: "Error"
                                          };
                                  } else {
                                    return Belt_Result.map(expression(advance(parser)), (function (else_) {
                                                  return {
                                                          value: {
                                                            TAG: 9,
                                                            _0: condition,
                                                            _1: $$then,
                                                            _2: else_,
                                                            [Symbol.for("name")]: "If"
                                                          },
                                                          line: token.line,
                                                          column: token.column,
                                                          start: token.position,
                                                          end: else_.end
                                                        };
                                                }));
                                  }
                                }));
                  }
                }));
  }
}

function lambda(parser) {
  var token = getToken(parser);
  var match = token.kind;
  if (match !== 11) {
    return {
            TAG: 0,
            _0: undefined,
            [Symbol.for("name")]: "Ok"
          };
  } else {
    return Belt_Result.flatMap(params(advance(parser)), (function (params) {
                  var match = getToken(parser).kind;
                  if (match !== 21) {
                    return {
                            TAG: 1,
                            _0: expectedButFound(parser.input, getToken(parser), undefined, "Expected a -> after the list of parameters for the function"),
                            [Symbol.for("name")]: "Error"
                          };
                  } else {
                    return Belt_Result.map(expression(advance(parser)), (function (expr) {
                                  return {
                                          value: {
                                            TAG: 6,
                                            _0: params,
                                            _1: expr,
                                            [Symbol.for("name")]: "Lambda"
                                          },
                                          line: token.line,
                                          column: token.column,
                                          start: token.position,
                                          end: expr.end
                                        };
                                }));
                  }
                }));
  }
}

function params(parser) {
  return Belt_Result.flatMap(pattern(parser), (function (pattern) {
                if (pattern !== undefined) {
                  return paramsStep(parser, [pattern]);
                } else {
                  return {
                          TAG: 1,
                          _0: expectedButFound(parser.input, getToken(parser), undefined, "Expected a list of parameters"),
                          [Symbol.for("name")]: "Error"
                        };
                }
              }));
}

function paramsStep(parser, patterns) {
  return Belt_Result.flatMap(pattern(parser), (function (pattern) {
                if (pattern !== undefined) {
                  patterns.push(pattern);
                  return paramsStep(parser, patterns);
                } else {
                  return {
                          TAG: 0,
                          _0: patterns,
                          [Symbol.for("name")]: "Ok"
                        };
                }
              }));
}

function pattern(parser) {
  var token = getToken(parser);
  var match = token.kind;
  if (match !== 22) {
    return {
            TAG: 0,
            _0: undefined,
            [Symbol.for("name")]: "Ok"
          };
  } else {
    advance(parser);
    return {
            TAG: 0,
            _0: $$Node.make({
                  _0: token.lexeme,
                  [Symbol.for("name")]: "Identifier"
                }, token, token),
            [Symbol.for("name")]: "Ok"
          };
  }
}

function binary(parser) {
  return Belt_Result.flatMap(unary(parser), (function (expr) {
                return Belt_Result.map(binaryStep(parser, []), (function (binops) {
                              return organizeBinops(expr, binops, {
                                          contents: 0
                                        }, 0);
                            }));
              }));
}

function binaryStep(parser, binops) {
  var token = getToken(parser);
  var match = token.kind;
  var op;
  switch (match) {
    case /* Minus */6 :
        op = Ast.Binop.substraction;
        break;
    case /* Plus */7 :
        op = Ast.Binop.addition;
        break;
    case /* Slash */10 :
        op = Ast.Binop.division;
        break;
    case /* Star */12 :
        op = Ast.Binop.multiplication;
        break;
    case /* BangEqual */14 :
        op = Ast.Binop.notEqual;
        break;
    case /* EqualEqual */16 :
        op = Ast.Binop.equal;
        break;
    case /* Greater */17 :
        op = Ast.Binop.greaterThan;
        break;
    case /* GreaterEqual */18 :
        op = Ast.Binop.greaterEqualThan;
        break;
    case /* Less */19 :
        op = Ast.Binop.lessThan;
        break;
    case /* LessEqual */20 :
        op = Ast.Binop.lessEqualThan;
        break;
    case /* And */25 :
        op = Ast.Binop.and_;
        break;
    case /* Or */26 :
        op = Ast.Binop.or;
        break;
    case /* LeftParen */0 :
    case /* RightParen */1 :
    case /* LeftBrace */2 :
    case /* RightBrace */3 :
    case /* Comma */4 :
    case /* Dot */5 :
    case /* Semicolon */8 :
    case /* Colon */9 :
    case /* Backslash */11 :
    case /* Bang */13 :
    case /* Equal */15 :
    case /* Arrow */21 :
    case /* Identifier */22 :
    case /* String */23 :
    case /* Float */24 :
    case /* Not */27 :
    case /* If */28 :
    case /* Then */29 :
    case /* Else */30 :
    case /* True */31 :
    case /* False */32 :
    case /* Let */33 :
    case /* Import */34 :
    case /* As */35 :
    case /* Exports */36 :
    case /* Module */37 :
    case /* Comment */38 :
    case /* Eof */39 :
        op = undefined;
        break;
    
  }
  if (op === undefined) {
    return {
            TAG: 0,
            _0: binops,
            [Symbol.for("name")]: "Ok"
          };
  }
  var opNode = $$Node.make(op, token, token);
  return Belt_Result.flatMap(unary(advance(parser)), (function (right) {
                binops.push([
                      opNode,
                      right
                    ]);
                return binaryStep(parser, binops);
              }));
}

function unary(parser) {
  var token = getToken(parser);
  var match = token.kind;
  var u = match !== 6 ? (
      match !== 27 ? undefined : (advance(parser), /* Not */0)
    ) : (advance(parser), /* Minus */1);
  return Belt_Result.map(call(parser), (function (expr) {
                if (u === undefined) {
                  return expr;
                }
                var op = $$Node.make(u, token, token);
                return {
                        value: {
                          TAG: 4,
                          _0: op,
                          _1: expr,
                          [Symbol.for("name")]: "Unary"
                        },
                        line: op.line,
                        column: op.column,
                        start: op.start,
                        end: expr.end
                      };
              }));
}

function call(parser) {
  var token = getToken(parser);
  return Belt_Result.flatMap(primary(parser), (function (expr) {
                if (expr !== undefined) {
                  return Belt_Result.map($$arguments(parser, token, []), (function (args) {
                                if (args.length === 0) {
                                  return expr;
                                }
                                var lastArg = Belt_Array.getExn(args, args.length - 1 | 0);
                                return {
                                        value: {
                                          TAG: 7,
                                          _0: expr,
                                          _1: args,
                                          [Symbol.for("name")]: "FnCall"
                                        },
                                        line: expr.line,
                                        column: expr.column,
                                        start: expr.start,
                                        end: lastArg.end
                                      };
                              }));
                } else {
                  return {
                          TAG: 1,
                          _0: expectedButFound(parser.input, getToken(parser), undefined, "Expected an expression (a number, string, a let binding, function call, an identifier, etc.)"),
                          [Symbol.for("name")]: "Error"
                        };
                }
              }));
}

function $$arguments(parser, firstToken, args) {
  if (isNestedIndent(parser, firstToken)) {
    return Belt_Result.flatMap(primary(parser), (function (arg) {
                  if (arg !== undefined) {
                    args.push(arg);
                    return $$arguments(parser, firstToken, args);
                  } else {
                    return {
                            TAG: 0,
                            _0: args,
                            [Symbol.for("name")]: "Ok"
                          };
                  }
                }));
  } else {
    return {
            TAG: 0,
            _0: args,
            [Symbol.for("name")]: "Ok"
          };
  }
}

function primary(parser) {
  var token = getToken(parser);
  var match = token.kind;
  var result;
  if (match !== 0) {
    if (match >= 22) {
      switch (match) {
        case /* Identifier */22 :
            result = {
              TAG: 0,
              _0: $$Node.make({
                    TAG: 3,
                    _0: token.lexeme,
                    [Symbol.for("name")]: "Identifier"
                  }, token, token),
              [Symbol.for("name")]: "Ok"
            };
            break;
        case /* String */23 :
            var value = token.lexeme.substring(1, token.lexeme.length - 1 | 0);
            result = {
              TAG: 0,
              _0: $$Node.make({
                    TAG: 2,
                    _0: value,
                    [Symbol.for("name")]: "String"
                  }, token, token),
              [Symbol.for("name")]: "Ok"
            };
            break;
        case /* Float */24 :
            var n = Belt_Float.fromString(token.lexeme);
            result = n !== undefined ? ({
                  TAG: 0,
                  _0: $$Node.make({
                        TAG: 1,
                        _0: n,
                        [Symbol.for("name")]: "Float"
                      }, token, token),
                  [Symbol.for("name")]: "Ok"
                }) : ({
                  TAG: 1,
                  _0: make(parser.input, token, undefined, "Failed to parse number token '" + token.lexeme + "'"),
                  [Symbol.for("name")]: "Error"
                });
            break;
        case /* True */31 :
            result = {
              TAG: 0,
              _0: $$Node.make({
                    TAG: 0,
                    _0: true,
                    [Symbol.for("name")]: "Bool"
                  }, token, token),
              [Symbol.for("name")]: "Ok"
            };
            break;
        case /* False */32 :
            result = {
              TAG: 0,
              _0: $$Node.make({
                    TAG: 0,
                    _0: false,
                    [Symbol.for("name")]: "Bool"
                  }, token, token),
              [Symbol.for("name")]: "Ok"
            };
            break;
        case /* And */25 :
        case /* Or */26 :
        case /* Not */27 :
        case /* If */28 :
        case /* Then */29 :
        case /* Else */30 :
        case /* Let */33 :
        case /* Import */34 :
        case /* As */35 :
        case /* Exports */36 :
        case /* Module */37 :
        case /* Comment */38 :
        case /* Eof */39 :
            result = {
              TAG: 0,
              _0: undefined,
              [Symbol.for("name")]: "Ok"
            };
            break;
        
      }
    } else {
      result = {
        TAG: 0,
        _0: undefined,
        [Symbol.for("name")]: "Ok"
      };
    }
  } else {
    var nextToken = getToken(advance(parser));
    var match$1 = nextToken.kind;
    result = Belt_Result.map(match$1 !== 1 ? Belt_Result.flatMap(expression(parser), (function (expr) {
                  var lastToken = getToken(parser);
                  var match = lastToken.kind;
                  if (match !== 1) {
                    return {
                            TAG: 1,
                            _0: expectedButFound(parser.input, lastToken, token, "Expected ')' after parenthesized expression"),
                            [Symbol.for("name")]: "Error"
                          };
                  } else {
                    return {
                            TAG: 0,
                            _0: expr,
                            [Symbol.for("name")]: "Ok"
                          };
                  }
                })) : ({
              TAG: 0,
              _0: $$Node.make(/* Unit */0, token, nextToken),
              [Symbol.for("name")]: "Ok"
            }), (function (ast) {
            return ast;
          }));
  }
  if (result.TAG === /* Ok */0) {
    if (result._0 !== undefined) {
      advance(parser);
    }
    
  }
  return result;
}

function file(parser) {
  var result = expression(parser);
  if (result.TAG !== /* Ok */0) {
    return {
            TAG: 1,
            _0: [result._0],
            [Symbol.for("name")]: "Error"
          };
  }
  var token = getToken(parser);
  if (token.kind >= 39) {
    return {
            TAG: 0,
            _0: result._0,
            [Symbol.for("name")]: "Ok"
          };
  } else {
    return {
            TAG: 1,
            _0: [expectedButFound(parser.input, token, undefined, "Expected the end of input")],
            [Symbol.for("name")]: "Error"
          };
  }
}

function parse(input, tokens) {
  return file({
              input: input,
              tokens: tokens,
              current: 0
            });
}

var $$String$1;

var JsArray;

export {
  $$String$1 as $$String,
  JsArray ,
  ParseError ,
  getToken ,
  advance ,
  organizeBinops ,
  isNestedIndent ,
  isNextLineSameIndent ,
  expression ,
  let_ ,
  if_ ,
  lambda ,
  params ,
  paramsStep ,
  pattern ,
  binary ,
  binaryStep ,
  unary ,
  call ,
  $$arguments ,
  primary ,
  file ,
  parse ,
  
}
/* No side effect */
