// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Ast from "./Ast.js";
import * as Json from "./Json.js";
import * as Test from "./Test.js";
import * as Type from "./Type.js";
import * as Curry from "../../../node_modules/rescript/lib/es6/curry.js";
import * as Infer from "./Infer.js";
import * as Parser from "./Parser.js";
import * as Tokenizer from "./Tokenizer.js";
import * as Belt_Array from "../../../node_modules/rescript/lib/es6/belt_Array.js";
import * as AssertsTs from "https://deno.land/std@0.97.0/testing/asserts.ts";

Test.suite("Infer", (function (param) {
        var test = param.test;
        var testCases = [
          [
            "\\f -> \\x -> f x",
            "(a -> b) -> a -> b"
          ],
          [
            "\\f -> \\x -> f (f x)",
            "(a -> a) -> a -> a"
          ],
          [
            "\\m -> \\n -> \\f -> \\x -> m f (n f x)",
            "(a -> b -> c) -> (a -> d -> b) -> a -> d -> c"
          ],
          [
            "\\n -> \\f -> \\x -> f (n f x)",
            "((a -> b) -> c -> a) -> (a -> b) -> c -> b"
          ],
          [
            "\\m -> \\n -> \\f -> \\x -> m (n f) x",
            "(a -> b -> c) -> (d -> a) -> d -> b -> c"
          ],
          [
            "\\n -> \\f -> \\x -> n (\\g -> \\h -> h (g f)) (\\u -> x) (\\u -> u)",
            "(((a -> b) -> (b -> c) -> c) -> (d -> e) -> (f -> f) -> g) -> a -> e -> g"
          ],
          [
            "\n      \\x ->\n        let y = x\n        y\n    ",
            "a -> a"
          ],
          [
            "\n      \\x ->\n        let y = \\z -> x\n        y\n      ",
            "a -> b -> a"
          ],
          [
            "if 1 == 1 then true else false",
            "Bool"
          ],
          [
            "if 1 == 1 then 1 else 2",
            "Float"
          ],
          [
            "if 1 == 1 then if 1 + 1 > 2 then 5 else 1 / 1 else 2 + 2",
            "Float"
          ],
          [
            "if 1 then 5 else 1",
            "1:3: Type mismatch:  Float  ≠  Bool\n\nExpected\n\n  1│  if 1 then 5 else 1\n   │     ↑\n\nto be\n\nBool\n\nbut seems to be\n\nFloat"
          ],
          [
            "let incr = \\n -> n + 1\n\nincr true",
            "3:0: Type mismatch:  Bool -> a  ≠  Float -> Float\n\nExpected\n\n  1│  let incr = \\n -> n + 1\n  2│  \n  3│  incr true\n   │  ↑↑↑↑↑↑↑↑↑\n\nto be\n\nFloat -> Float\n\nbut seems to be\n\nBool -> a"
          ],
          [
            "\\x ->\n    let a = x + 1\n    let b = not x\n    x",
            "3:16: Type mismatch:  Float  ≠  Bool\n\nExpected\n\n  1│  \\x ->\n  2│      let a = x + 1\n  3│      let b = not x\n   │                  ↑\n  4│      x\n\nto be\n\nBool\n\nbut seems to be\n\nFloat"
          ],
          [
            "let a = bar\nbar",
            "1:8: Undefined identifier bar\n\n  1│  let a = bar\n   │          ↑↑↑\n  2│  bar\n\n----------------------------------------\n\n2:0: Undefined identifier bar\n\n  1│  let a = bar\n  2│  bar\n   │  ↑↑↑"
          ]
        ];
        return Belt_Array.forEachWithIndex(testCases, (function (i, param) {
                      var expected = param[1];
                      var input = param[0];
                      var subject = Belt_Array.getExn(Belt_Array.keep(input.split("\n"), (function (s) {
                                  return s.length !== 0;
                                })), 0);
                      return Curry._2(test, "" + i + ". \"" + subject + "\"", (function (param) {
                                    var tokens = Tokenizer.parse(input);
                                    if (tokens.TAG === /* Ok */0) {
                                      var ast = Parser.parse(input, tokens._0);
                                      if (ast.TAG === /* Ok */0) {
                                        var ast$1 = ast._0;
                                        var typ = Infer.infer(ast$1);
                                        if (typ.TAG === /* Ok */0) {
                                          var typ$1 = typ._0;
                                          var typStr = Type.toString(typ$1);
                                          var astStr = Ast.Expression.toString(ast$1.value);
                                          if (!AssertsTs.equal(typStr, expected)) {
                                            console.log("\n", Json.stringifyAnyWithSpace(typ$1, 4));
                                            console.log("\n", Json.stringifyAnyWithSpace(ast$1, 4));
                                            console.log("\n\n", Json.stringifyAnyWithSpace(typStr, 4));
                                            console.log("\n", Json.stringifyAnyWithSpace(astStr, 4));
                                          }
                                          AssertsTs.assertEquals(typStr, expected, "");
                                          return ;
                                        }
                                        AssertsTs.assertEquals(Infer.InferError.toStringMany(typ._0, input), expected, "");
                                        return ;
                                      }
                                      var ss = Belt_Array.map(ast._0, (function (a) {
                                              return a.message;
                                            }));
                                      ss.splice(0, 0, "Error parsing test input");
                                      AssertsTs.fail(ss.join("\n\n"));
                                      return ;
                                    }
                                    var ss$1 = Belt_Array.map(tokens._0, (function (a) {
                                            return a.message;
                                          }));
                                    ss$1.splice(0, 0, "Error tokenizing test input");
                                    AssertsTs.fail(ss$1.join("\n\n"));
                                    
                                  }));
                    }));
      }));

export {
  
}
/*  Not a pure module */
