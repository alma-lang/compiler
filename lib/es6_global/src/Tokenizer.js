// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml from "../../../node_modules/rescript/lib/es6/caml.js";
import * as Input from "./Input.js";
import * as Js_exn from "../../../node_modules/rescript/lib/es6/js_exn.js";
import * as Belt_Option from "../../../node_modules/rescript/lib/es6/belt_Option.js";

var forEachCodePoint = (function(input, fn) {
  for (let codePoint of input) {
    fn(codePoint.codePointAt(0))
  }
});

var zero = "0".charCodeAt(0) | 0;

var nine = "9".charCodeAt(0) | 0;

function isDigit(s) {
  var cp = s.codePointAt(0);
  if (cp !== undefined && cp >= zero) {
    return cp <= nine;
  } else {
    return false;
  }
}

var identifierStartRe = /[\p{Lu}\p{Ll}\p{Lt}\p{Lm}\p{Lo}\p{Nl}_]/u;

var identifierRestRe = /[\p{Lu}\p{Ll}\p{Lt}\p{Lm}\p{Lo}\p{Nl}\p{Mn}\p{Mc}\p{Nd}\p{Pc}_]/u;

function isIdentifierChar(s, isStart) {
  return (
            isStart ? identifierStartRe : identifierRestRe
          ).test(s);
}

function peek(state) {
  var nextCharStart = state.current + state.currentChar.length | 0;
  if (nextCharStart >= state.input.length) {
    return ;
  } else {
    return Belt_Option.map(state.input.codePointAt(nextCharStart), (function (prim) {
                  return String.fromCodePoint(prim);
                }));
  }
}

function peekSecond(state) {
  var c = peek(state);
  if (c === undefined) {
    return ;
  }
  var secondCharStart = (state.current + state.currentChar.length | 0) + c.length | 0;
  if (secondCharStart >= state.input.length) {
    return ;
  } else {
    return Belt_Option.map(state.input.codePointAt(secondCharStart), (function (prim) {
                  return String.fromCodePoint(prim);
                }));
  }
}

function pushToken(state, token) {
  state.tokens.push(token);
  
}

function nextTokenStart(state) {
  return state.current + state.currentChar.length | 0;
}

function resetForNextToken(state) {
  state.start = nextTokenStart(state);
  state.status = /* SingleToken */0;
  
}

function lexeme(state) {
  return state.input.substring(state.start, nextTokenStart(state));
}

function addToken(state, kind) {
  pushToken(state, {
        kind: kind,
        lexeme: lexeme(state),
        position: state.start,
        line: state.line,
        column: state.start - state.lineStartPosition | 0,
        indent: state.indent
      });
  return resetForNextToken(state);
}

function addError(state, useStartOpt, message) {
  var useStart = useStartOpt !== undefined ? useStartOpt : false;
  var match = useStart ? [
      state.start,
      state.start - state.lineStartPosition | 0
    ] : [
      state.current,
      state.current - state.lineStartPosition | 0
    ];
  var column = match[1];
  var message$1 = String(state.line) + ":" + String(column) + "\n" + message + "\n" + Belt_Option.getWithDefault(Input.linesReportAtPositionWithPointer(state.input, match[0], state.line, column), "");
  state.errors.push({
        line: state.line,
        column: column,
        message: message$1
      });
  return resetForNextToken(state);
}

function parseToken(state) {
  while(true) {
    var tokenType = state.status;
    if (typeof tokenType === "number") {
      switch (tokenType) {
        case /* SingleToken */0 :
            var ch = state.currentChar;
            switch (ch) {
              case "" :
              case "\t" :
              case "\r" :
                  return resetForNextToken(state);
              case "\n" :
              case " " :
                  state.status = {
                    TAG: 1,
                    _0: false,
                    [Symbol.for("name")]: "WhitespaceToken"
                  };
                  continue ;
              case "!" :
                  var match = peek(state);
                  if (match === "=") {
                    state.status = {
                      TAG: 0,
                      _0: /* BangEqual */13,
                      [Symbol.for("name")]: "DoubleToken"
                    };
                    return ;
                  } else {
                    return addToken(state, /* Bang */12);
                  }
              case "\"" :
                  state.status = /* StringToken */2;
                  return ;
              case "(" :
                  return addToken(state, /* LeftParen */0);
              case ")" :
                  return addToken(state, /* RightParen */1);
              case "*" :
                  return addToken(state, /* Star */11);
              case "+" :
                  return addToken(state, /* Plus */7);
              case "," :
                  return addToken(state, /* Comma */4);
              case "-" :
                  return addToken(state, /* Minus */6);
              case "." :
                  return addToken(state, /* Dot */5);
              case "/" :
                  var match$1 = peek(state);
                  if (match$1 === "/") {
                    state.status = /* LineCommentToken */1;
                    return ;
                  } else {
                    return addToken(state, /* Slash */10);
                  }
              case ":" :
                  return addToken(state, /* Colon */9);
              case ";" :
                  return addToken(state, /* Semicolon */8);
              case "<" :
                  var match$2 = peek(state);
                  if (match$2 === "=") {
                    state.status = {
                      TAG: 0,
                      _0: /* LessEqual */19,
                      [Symbol.for("name")]: "DoubleToken"
                    };
                    return ;
                  } else {
                    return addToken(state, /* Less */18);
                  }
              case "=" :
                  var match$3 = peek(state);
                  if (match$3 === "=") {
                    state.status = {
                      TAG: 0,
                      _0: /* EqualEqual */15,
                      [Symbol.for("name")]: "DoubleToken"
                    };
                    return ;
                  } else {
                    return addToken(state, /* Equal */14);
                  }
              case ">" :
                  var match$4 = peek(state);
                  if (match$4 === "=") {
                    state.status = {
                      TAG: 0,
                      _0: /* GreaterEqual */17,
                      [Symbol.for("name")]: "DoubleToken"
                    };
                    return ;
                  } else {
                    return addToken(state, /* Greater */16);
                  }
              case "{" :
                  return addToken(state, /* LeftBrace */2);
              case "}" :
                  return addToken(state, /* RightBrace */3);
              default:
                if (isDigit(ch)) {
                  state.status = {
                    TAG: 2,
                    _0: false,
                    [Symbol.for("name")]: "NumberToken"
                  };
                  continue ;
                }
                if (!isIdentifierChar(ch, true)) {
                  return addError(state, undefined, "Unexpected character '" + ch + "'.");
                }
                state.status = {
                  TAG: 3,
                  _0: true,
                  [Symbol.for("name")]: "IdentifierToken"
                };
                continue ;
            }
        case /* LineCommentToken */1 :
            var match$5 = state.currentChar;
            switch (match$5) {
              case "" :
              case "\n" :
                  return addToken(state, /* Comment */37);
              default:
                return ;
            }
        case /* StringToken */2 :
            var match$6 = state.currentChar;
            switch (match$6) {
              case "" :
                  return addError(state, true, "Unclosed string.");
              case "\"" :
                  return addToken(state, /* String */21);
              default:
                return ;
            }
        
      }
    } else {
      switch (tokenType.TAG | 0) {
        case /* DoubleToken */0 :
            return addToken(state, tokenType._0);
        case /* WhitespaceToken */1 :
            var lineStarted = tokenType._0;
            var match$7 = state.currentChar;
            switch (match$7) {
              case "\n" :
                  state.status = {
                    TAG: 1,
                    _0: true,
                    [Symbol.for("name")]: "WhitespaceToken"
                  };
                  state.line = state.line + 1 | 0;
                  state.indent = 0;
                  state.lineStartPosition = state.current + 1 | 0;
                  break;
              case " " :
                  if (lineStarted) {
                    state.indent = state.indent + 1 | 0;
                  }
                  state.status = {
                    TAG: 1,
                    _0: lineStarted,
                    [Symbol.for("name")]: "WhitespaceToken"
                  };
                  break;
              default:
                Js_exn.raiseError("Got to the whitespace tokenizer without a valid space or newline char.");
            }
            var match$8 = peek(state);
            if (match$8 === undefined) {
              return resetForNextToken(state);
            }
            switch (match$8) {
              case "\n" :
              case " " :
                  return ;
              default:
                return resetForNextToken(state);
            }
        case /* NumberToken */2 :
            var c = state.currentChar;
            if (c === ".") {
              if (tokenType._0) {
                addError(state, undefined, "Multiple dots while parsing a number.");
              } else {
                state.status = {
                  TAG: 2,
                  _0: true,
                  [Symbol.for("name")]: "NumberToken"
                };
              }
              var c$1 = peek(state);
              if (c$1 !== undefined) {
                if (isDigit(c$1)) {
                  return ;
                } else {
                  return addError(state, undefined, "Expected more digits after a dot in a number.");
                }
              } else {
                return addError(state, undefined, "Expected more digits after a dot in a number.");
              }
            }
            if (!isDigit(c)) {
              return Js_exn.raiseError("Got to the number tokenizer without a valid number digit.");
            }
            var c$2 = peek(state);
            if (c$2 !== undefined && (c$2 === "." || isDigit(c$2))) {
              return ;
            } else {
              return addToken(state, /* Number */22);
            }
        case /* IdentifierToken */3 :
            var c$3 = state.currentChar;
            if (!isIdentifierChar(c$3, tokenType._0)) {
              return Js_exn.raiseError("Got to the identifier tokenizer without a valid number digit.");
            }
            state.status = {
              TAG: 3,
              _0: false,
              [Symbol.for("name")]: "IdentifierToken"
            };
            var c$4 = peek(state);
            if (c$4 !== undefined && isIdentifierChar(c$4, false)) {
              return ;
            }
            var match$9 = lexeme(state);
            var tmp;
            switch (match$9) {
              case "and" :
                  tmp = /* And */23;
                  break;
              case "as" :
                  tmp = /* As */34;
                  break;
              case "else" :
                  tmp = /* Else */28;
                  break;
              case "exports" :
                  tmp = /* Exports */35;
                  break;
              case "false" :
                  tmp = /* False */30;
                  break;
              case "fn" :
                  tmp = /* Fun */31;
                  break;
              case "if" :
                  tmp = /* If */26;
                  break;
              case "import" :
                  tmp = /* Import */33;
                  break;
              case "let" :
                  tmp = /* Let */32;
                  break;
              case "module" :
                  tmp = /* Module */36;
                  break;
              case "not" :
                  tmp = /* Not */25;
                  break;
              case "or" :
                  tmp = /* Or */24;
                  break;
              case "then" :
                  tmp = /* Then */27;
                  break;
              case "true" :
                  tmp = /* True */29;
                  break;
              default:
                tmp = /* Identifier */20;
            }
            return addToken(state, tmp);
            break;
        
      }
    }
  };
}

function parse(input) {
  var state = {
    status: /* SingleToken */0,
    input: input,
    tokens: [],
    errors: [],
    start: 0,
    current: 0,
    line: 1,
    lineStartPosition: 0,
    indent: 0,
    currentChar: ""
  };
  forEachCodePoint(input, (function (i) {
          state.currentChar = String.fromCodePoint(i);
          parseToken(state);
          state.current = state.current + state.currentChar.length | 0;
          
        }));
  state.currentChar = "";
  parseToken(state);
  pushToken(state, {
        kind: /* Eof */38,
        lexeme: "[End of file]",
        position: input.length - 1 | 0,
        line: state.line,
        column: Caml.caml_int_max(state.current - state.lineStartPosition | 0, 0),
        indent: state.indent
      });
  if (state.errors.length !== 0) {
    return {
            TAG: 1,
            _0: state.errors,
            [Symbol.for("name")]: "Error"
          };
  } else {
    return {
            TAG: 0,
            _0: state.tokens,
            [Symbol.for("name")]: "Ok"
          };
  }
}

var $$String$1;

var JsArray;

export {
  forEachCodePoint ,
  $$String$1 as $$String,
  JsArray ,
  isDigit ,
  identifierStartRe ,
  identifierRestRe ,
  isIdentifierChar ,
  peek ,
  peekSecond ,
  pushToken ,
  nextTokenStart ,
  resetForNextToken ,
  lexeme ,
  addToken ,
  addError ,
  parseToken ,
  parse ,
  
}
/* zero Not a pure module */
